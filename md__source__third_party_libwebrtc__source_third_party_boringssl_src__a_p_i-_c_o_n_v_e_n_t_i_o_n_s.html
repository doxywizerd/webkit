<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>webkit: BoringSSL API Conventions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">webkit
   &#160;<span id="projectnumber">2cdf99a9e3038c7e01b3c37e8ad903ecbe5eecf1</span>
   </div>
   <div id="projectbrief">https://github.com/WebKit/webkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">BoringSSL <a class="el" href="namespace_a_p_i.html">API</a> Conventions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes conventions for BoringSSL APIs. <a class="el" href="protocol_the-p.html">The</a> /STYLE.md "style
guide" also includes guidelines, but this document is targeted at both <a class="el" href="namespace_a_p_i.html">API</a> consumers and developers.</p>
<h2>Documentation</h2>
<p>All supported public APIs are documented in the public header files, found in <code>include/openssl</code>. <a class="el" href="protocol_the-p.html">The</a> <a class="el" href="namespace_a_p_i.html">API</a> documentation is also available <a href="https://commondatastorage.googleapis.com/chromium-boringssl-docs/headers.html">online</a>.</p>
<p>Some headers lack documention comments. These are functions and structures from OpenSSL's legacy ASN.1, X.509, and PEM implementation. If possible, avoid using them. These are left largely unmodified from upstream and are retained only for compatibilty with existing OpenSSL consumers.</p>
<h1>Forward declarations</h1>
<p>Do not write <code>typedef struct foo_st FOO</code> or try otherwise to define BoringSSL's types. Including <code>openssl/base.h</code> (or <code>openssl/ossl_typ.h</code> for consumers who wish to be OpenSSL-compatible) will forward-declare each type without importing the rest of the library or invasive macros.</p>
<h2>Error-handling</h2>
<p>Most functions in BoringSSL may fail, either due to allocation failures or input errors. Functions which return an <code>int</code> typically return one on success and zero on failure. Functions which return a pointer typically return <code>NULL</code> on failure. However, due to legacy constraints, some functions are more complex. Consult the <a class="el" href="namespace_a_p_i.html">API</a> documentation before using a function.</p>
<p>On error, most functions also push errors on the error queue, an <code>errno</code>-like mechanism. See the documentation for <a href="https://commondatastorage.googleapis.com/chromium-boringssl-docs/err.h.html">err.h</a> for more details.</p>
<p>As with <code>errno</code>, callers must test the function's return value, not the error queue to determine whether an operation failed. Some codepaths may not interact with the error queue, and the error queue may have state from a previous failed operation.</p>
<p>When ignoring a failed operation, it is recommended to call <code>ERR_clear_error</code> to avoid the state interacting with future operations. Failing to do so should not affect the actual behavior of any functions, but may result in errors from both operations being mixed in error logging. We hope to <a href="https://bugs.chromium.org/p/boringssl/issues/detail?id=38">improve</a> this situation in the future.</p>
<p>Where possible, avoid conditioning on specific reason codes and limit usage to logging. <a class="el" href="protocol_the-p.html">The</a> reason codes are very specific and may change over time.</p>
<h2>Memory allocation</h2>
<p>BoringSSL allocates memory via <code>OPENSSL_malloc</code>, found in <code>mem.h</code>. Use <code>OPENSSL_free</code>, found in the same header file, to release it. BoringSSL functions will fail gracefully on allocation error, but it is recommended to use a <code>malloc</code> implementation that <code>abort</code>s on failure.</p>
<h2><a class="el" href="struct_object.html">Object</a> initialization and cleanup</h2>
<p>BoringSSL defines a number of structs for use in its APIs. It is a <a class="el" href="class_c.html">C</a> library, so the caller is responsible for ensuring these structs are properly initialized and released. Consult the documentation for a module for the proper use of its types. Some general conventions are listed below.</p>
<h3>Heap-allocated types</h3>
<p>Some types, such as <code>RSA</code>, are heap-allocated. All instances will be allocated and returned from BoringSSL's APIs. It is an error to instantiate a heap- allocated type on the stack or embedded within another object.</p>
<p>Heap-allocated types may have functioned named like <code>RSA_new</code> which allocates a fresh blank <code>RSA</code>. Other functions may also return newly-allocated instances. For example, <code>RSA_parse_public_key</code> is documented to return a newly-allocated <code>RSA</code> object.</p>
<p>Heap-allocated objects must be released by the corresponding free function, named like <code>RSA_free</code>. Like <a class="el" href="class_c.html">C</a>'s <code>free</code> and C++'s <code>delete</code>, all free functions internally check for <code>NULL</code>. Consumers are not required to check for <code>NULL</code> before calling.</p>
<p><a class="el" href="struct_a.html">A</a> heap-allocated type may be reference-counted. In this case, a function named like <code>RSA_up_ref</code> will be available to take an additional reference count. <a class="el" href="protocol_the-p.html">The</a> free function must be called to decrement the reference count. It will only release resources when the final reference is released. For OpenSSL compatibility, these functions return <code>int</code>, but callers may assume they always successfully return one because reference counts use saturating arithmetic.</p>
<p>C++ consumers are recommended to use <code>bssl::UniquePtr</code> to manage heap-allocated objects. <code>bssl::UniquePtr&lt;T&gt;</code>, like other types, is forward-declared in <code>openssl/base.h</code>. Code that needs access to the free functions, such as code which destroys a <code>bssl::UniquePtr</code>, must include the corresponding module's header. (This matches <code>std::unique_ptr</code>'s relationship with forward declarations.)</p>
<h3>Stack-allocated types</h3>
<p>Other types in BoringSSL are stack-allocated, such as <code>EVP_MD_CTX</code>. These types may be allocated on the stack or embedded within another object. However, they must still be initialized before use.</p>
<p>Every stack-allocated object in BoringSSL has a <em>zero state</em>, analogous to initializing a pointer to <code>NULL</code>. In this state, the object may not be completely initialized, but it is safe to call cleanup functions. Entering the zero state cannot fail. (It is usually <code>memset(0)</code>.)</p>
<p><a class="el" href="protocol_the-p.html">The</a> function to enter the zero state is named like <code>EVP_MD_CTX_init</code> or <code>CBB_zero</code> and will always return <code>void</code>. To release resources associated with the type, call the cleanup function, named like <code>EVP_MD_CTX_cleanup</code>. <a class="el" href="protocol_the-p.html">The</a> cleanup function must be called on all codepaths, regardless of success or failure. For example: </p><pre class="fragment">uint8_t md[EVP_MAX_MD_SIZE];
unsigned md_len;
EVP_MD_CTX ctx;
EVP_MD_CTX_init(&amp;ctx);  /* Enter the zero state. */
int ok = EVP_DigestInit_ex(&amp;ctx, EVP_sha256(), NULL) &amp;&amp;
         EVP_DigestUpdate(&amp;ctx, "hello ", 6) &amp;&amp;
         EVP_DigestUpdate(&amp;ctx, "world", 5) &amp;&amp;
         EVP_DigestFinal_ex(&amp;ctx, md, &amp;md_len);
EVP_MD_CTX_cleanup(&amp;ctx);  /* Release |ctx|. */
</pre><p>Note that <code>EVP_MD_CTX_cleanup</code> is called whether or not the <code>EVP_Digest*</code> operations succeeded. More complex <a class="el" href="class_c.html">C</a> functions may use the <code>goto err</code> pattern: </p><pre class="fragment">  int ret = 0;
  EVP_MD_CTX ctx;
  EVP_MD_CTX_init(&amp;ctx);

  if (!some_other_operation()) {
    goto err;
  }

  uint8_t md[EVP_MAX_MD_SIZE];
  unsigned md_len;
  if (!EVP_DigestInit_ex(&amp;ctx, EVP_sha256(), NULL) ||
      !EVP_DigestUpdate(&amp;ctx, "hello ", 6) ||
      !EVP_DigestUpdate(&amp;ctx, "world", 5) ||
      !EVP_DigestFinal_ex(&amp;ctx, md, &amp;md_len) {
    goto err;
  }

  ret = 1;

err:
  EVP_MD_CTX_cleanup(&amp;ctx);
  return ret;
</pre><p>Note that, because <code>ctx</code> is set to the zero state before any failures, <code>EVP_MD_CTX_cleanup</code> is safe to call even if the first operation fails before <code>EVP_DigestInit_ex</code>. However, it would be illegal to move the <code>EVP_MD_CTX_init</code> below the <code>some_other_operation</code> call.</p>
<p>As a rule of thumb, enter the zero state of stack-allocated structs in the same place they are declared.</p>
<p>C++ consumers are recommended to use the wrappers named like <code>bssl::ScopedEVP_MD_CTX</code>, defined in the corresponding module's header. These wrappers are automatically initialized to the zero state and are automatically cleaned up.</p>
<h3>Data-only types</h3>
<p><a class="el" href="struct_a.html">A</a> few types, such as <code>SHA_CTX</code>, are data-only types and do not require cleanup. These are usually for low-level cryptographic operations. These types may be used freely without special cleanup conventions.</p>
<h2>Thread safety</h2>
<p>BoringSSL is internally aware of the platform threading library and calls into it as needed. Consult the <a class="el" href="namespace_a_p_i.html">API</a> documentation for the threading guarantees of particular objects. In general, stateless reference-counted objects like <code>RSA</code> or <code>EVP_PKEY</code> which represent keys may typically be used from multiple threads simultaneously, provided no thread mutates the key. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
