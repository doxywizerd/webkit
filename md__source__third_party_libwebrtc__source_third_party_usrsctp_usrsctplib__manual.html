<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>webkit: SCTP user-land implementation (usrsctp)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">webkit
   &#160;<span id="projectnumber">2cdf99a9e3038c7e01b3c37e8ad903ecbe5eecf1</span>
   </div>
   <div id="projectbrief">https://github.com/WebKit/webkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">SCTP user-land implementation (usrsctp) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>SCTP is a message oriented, reliable transport protocol with direct support for multihoming that runs on top of IP or UDP, and supports both v4 and v6 versions.</p>
<p>Like TCP, SCTP provides reliable, connection oriented data delivery with congestion control. Unlike TCP, SCTP also provides message boundary preservation, ordered and unordered message delivery, multi-streaming and multi-homing. Detection of data corruption, loss of data and duplication of data is achieved by using checksums and sequence numbers. <a class="el" href="struct_a.html">A</a> selective retransmission mechanism is applied to correct loss or corruption of data.</p>
<p>In this manual the socket <a class="el" href="namespace_a_p_i.html">API</a> for the SCTP User-land implementation will be described. It is based on <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>. <a class="el" href="protocol_the-p.html">The</a> main focus of this document is on pointing out the differences to the SCTP Sockets <a class="el" href="namespace_a_p_i.html">API</a>. For all aspects of the sockets <a class="el" href="namespace_a_p_i.html">API</a> that are not mentioned in this document, please refer to <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>. Questions about SCTP itself can hopefully be answered by <a href="http://tools.ietf.org/html/rfc4960">RFC 4960</a>.</p>
<h2>Getting Started</h2>
<p><a class="el" href="protocol_the-p.html">The</a> user-land stack has been tested on FreeBSD 10.0, Ubuntu 11.10, Windows 7, Mac OS X 10.6, and Mac OS X 10.7. <a class="el" href="protocol_the-p.html">The</a> current version of the user-land stack is provided on <a href="https://github.com/sctplab/usrsctp">github</a>. Download the tarball and untar it in a folder of your choice. <a class="el" href="protocol_the-p.html">The</a> tarball contains all the sources to build the libusrsctp, which has to be linked to the object file of an example program. In addition there are two applications in the folder <code>programs</code> that can be built and run.</p>
<h3>Building the Library and the Applications</h3>
<h4>Unix-like Operating Systems</h4>
<p>In the folder <code>usrsctp</code> type </p><pre class="fragment">$ ./bootstrap
$ ./configure
$ make
</pre><p>Now, the library <code>libusrsctp.la</code> has been built in the subdirectory <code>usrsctplib</code>, and the example programs are ready to run from the subdirectory <code>programs</code>.</p>
<p>If you have root privileges or are in the sudoer group, you can install the library in <code>/usr/local/lib</code> and copy the header file to <code>/usr/include</code> with the command </p><pre class="fragment">$ sudo make install
</pre><h4>Windows</h4>
<p>On Windows you need a compiler like Microsoft Visual Studio. You can build the library and the example programs with the command line tool of the compiler by typing </p><pre class="fragment">$ nmake -f Makefile.nmake
</pre><p>in the directory <code>usrsctp</code>.</p>
<h4>CMake</h4>
<p>Create a directory outside the <code>usrsctp</code> directory, enter it and generate files by typing </p><pre class="fragment">$ cmake &lt;path-to-usrsctp-sources&gt;
$ cmake --build .
</pre><p>By default CMake generates a DEBUG build with verbose output.</p>
<h3>Running the <a class="el" href="struct_test.html">Test</a> Programs</h3>
<p>Several test programs are included, including a discard server and a client. You can run both to send data from the client to the server. <a class="el" href="protocol_the-p.html">The</a> client reads data from stdin and sends them to the server, which prints the message in the terminal and discards it. <a class="el" href="protocol_the-p.html">The</a> sources of the server are also provided <a href="https://github.com/sctplab/usrsctp/blob/master/programs/discard_server.c">here</a> and those of the client <a href="https://github.com/sctplab/usrsctp/blob/master/programs/client.c">here</a>.</p>
<h3>Using UDP Encapsulation</h3>
<p>Both programs can either send data over SCTP directly or use UDP encapsulation, thus encapsulating the SCTP packet in a UDP datagram. <a class="el" href="protocol_the-p.html">The</a> first mode works on loopback or in a protected setup without any NAT boxes involved. In all other cases it is better to use UDP encapsulation.</p>
<p><a class="el" href="protocol_the-p.html">The</a> usage of the <code>discard_server</code> is </p><pre class="fragment">$ discard_server [local_encaps_port remote_encaps_port]
</pre><p>For UDP encapsulation the ports have to be specified. <a class="el" href="protocol_the-p.html">The</a> local and remote encapsulation ports can be arbitrarily set. For example, you can call </p><pre class="fragment">$ ./discard_server 11111 22222
</pre><p>on a Unix-like OS and </p><pre class="fragment">$ discard_server.exe 11111 22222
</pre><p>on Windows.</p>
<p><a class="el" href="protocol_the-p.html">The</a> client needs two additional parameters, the server's address and its port. Its usage is </p><pre class="fragment">$ client remote_addr remote_port [local_port local_encaps_port remote_encaps_port]
</pre><p><a class="el" href="protocol_the-p.html">The</a> remote address is the server's address. If client and server are started on the same machine, the loopback address <code>127.0.0.1</code> can be used for Unix-like OSs and the local address on Windows. <a class="el" href="protocol_the-p.html">The</a> discard port is 9, thus 9 has to be taken as remote port. <a class="el" href="protocol_the-p.html">The</a> encapsulation ports have to match those of the server, i.e. the server's <code>local_encaps_port</code> is the client's <code>remote_encaps_port</code> and vice versa. Thus, the client can be started with </p><pre class="fragment">$ ./client 127.0.0.1 9 0 22222 11111
</pre><p>on a Unix-like OS and </p><pre class="fragment">$ client.exe 192.168.0.1 9 0 22222 11111
</pre><p>on Windows provided your local IP address is 192.168.0.1.</p>
<h3>Sending over SCTP</h3>
<p>To send data over SCTP directly you might need root privileges because raw sockets are used. Thus instead of specifying the encapsulation ports you have to start the programs prepending <code>sudo</code> or in case of Windows start the program from an administrator console.</p>
<h3>Using the Callback <a class="el" href="namespace_a_p_i.html">API</a></h3>
<p>Instead of asking constantly for new data, a callback <a class="el" href="namespace_a_p_i.html">API</a> can be used that is triggered by SCTP. <a class="el" href="struct_a.html">A</a> callback function has to be registered that will be called whenever data is ready to be delivered to the application.</p>
<p><a class="el" href="protocol_the-p.html">The</a> <code>discard_server</code> has a flag to switch between the two modi. If <code>use_cb</code> is set to 1, the callback <a class="el" href="namespace_a_p_i.html">API</a> will be used. To change the setting, just set the flag and compile the program again.</p>
<h2>Basic Operations</h2>
<p>All system calls start with the prefix <code>usrsctp_</code> to distinguish them from the kernel variants. Some of them are changed to account for the different demands in the userland environment.</p>
<h2>Differences to RFC 6458</h2>
<h3><a class="el" href="user__socket_8c.html#a10dc054fdd0cd237a76ac2141819c32b">usrsctp_init()</a></h3>
<p>Every application has to start with <code><a class="el" href="user__socket_8c.html#a10dc054fdd0cd237a76ac2141819c32b">usrsctp_init()</a></code>. This function calls <code><a class="el" href="sctp__usrreq_8c.html#ad2dd6224cfeb0925d54ec6fe7e5b53f8">sctp_init()</a></code> and reserves the memory necessary to administer the data transfer. <a class="el" href="protocol_the-p.html">The</a> function prototype is</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="user__socket_8c.html#a10dc054fdd0cd237a76ac2141819c32b">usrsctp_init</a>(<a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2_web_core_8framework_2_versions_2_a_2_privatc2dad1314081d5d61224d82bea996c93.html#a273cf69d639a59973b6019625df33e30">uint16_t</a> udp_port)</div></div><!-- fragment --><p>As it is not always possible to send data directly over SCTP because not all NAT boxes can process SCTP packets, the data can be sent over UDP. To encapsulate SCTP into UDP a UDP port has to be specified, to which the datagrams can be sent. This local UDP port is set with the parameter <code>udp_port</code>. <a class="el" href="protocol_the-p.html">The</a> default value is 9899, the standard UDP encapsulation port. If UDP encapsulation is not necessary, the UDP port has to be set to 0.</p>
<h3><a class="el" href="user__socket_8c.html#ae646261b94a92850b503bbc94f41b844">usrsctp_finish()</a></h3>
<p>At the end of the program <code><a class="el" href="user__socket_8c.html#ae646261b94a92850b503bbc94f41b844">usrsctp_finish()</a></code> should be called to free all the memory that has been allocated before. <a class="el" href="protocol_the-p.html">The</a> function prototype is</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="user__socket_8c.html#ae646261b94a92850b503bbc94f41b844">usrsctp_finish</a>(<span class="keywordtype">void</span>)</div></div><!-- fragment --><p><a class="el" href="protocol_the-p.html">The</a> return code is 0 on success and -1 in case of an error.</p>
<h3><a class="el" href="user__socket_8c.html#a687a015e27c2910886dd371596478209">usrsctp_socket()</a></h3>
<p><a class="el" href="struct_a.html">A</a> representation of an SCTP endpoint is a socket. Is it created with <code><a class="el" href="user__socket_8c.html#a687a015e27c2910886dd371596478209">usrsctp_socket()</a></code>. <a class="el" href="protocol_the-p.html">The</a> function prototype is</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structsocket.html">socket</a> *</div><div class="line"><a class="code" href="user__socket_8c.html#a687a015e27c2910886dd371596478209">usrsctp_socket</a>(<span class="keywordtype">int</span> <a class="code" href="_web_kit_cookie_manager_8h.html#a189d6886aee7fa9b500b0c81996fd1d0">domain</a>,</div><div class="line">               <span class="keywordtype">int</span> <a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2usr_2local_2include_2_a_n_g_l_e_2eglext_8h.html#adc7eac624fae77f95e4c32395ca628b8">type</a>,</div><div class="line">               <span class="keywordtype">int</span> <a class="code" href="_r_t_c_peer_connection_8idl.html#a0c1afae3f2d26264f1e0fb3caf59e766">protocol</a>,</div><div class="line">               <span class="keywordtype">int</span> (*receive_cb)(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *sock,</div><div class="line">                                 <span class="keyword">union</span> <a class="code" href="unionsctp__sockstore.html">sctp_sockstore</a> addr,</div><div class="line">                                 <span class="keywordtype">void</span> *<a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2usr_2local_2include_2_a_n_g_l_e_2eglext_8h.html#a77bef421a06300ba60fc8c18453bcaef">data</a>,</div><div class="line">                                 <span class="keywordtype">size_t</span> datalen,</div><div class="line">                                 <span class="keyword">struct</span> <a class="code" href="structsctp__rcvinfo.html">sctp_rcvinfo</a>,</div><div class="line">                                 <span class="keywordtype">int</span> <a class="code" href="namespaceflags.html">flags</a>),</div><div class="line">               <span class="keywordtype">int</span> (*send_cb)(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *sock,</div><div class="line">                              <a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2_web_core_8framework_2_versions_2_a_2_privatc2dad1314081d5d61224d82bea996c93.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> sb_free),</div><div class="line">               <a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2_web_core_8framework_2_versions_2_a_2_privatc2dad1314081d5d61224d82bea996c93.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> sb_threshold)</div></div><!-- fragment --><p>and the arguments taken from <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a> are</p>
<ul>
<li>domain: PF_INET or PF_INET6 can be used.</li>
<li>type: In case of a one-to-many style socket it is SOCK_SEQPACKET, in case of a one-to-one style socket it is SOCK_STREAM. For an explanation of the differences between the socket types please refer to <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>.</li>
<li>protocol: Set IPPROTO_SCTP.</li>
</ul>
<p>In usrsctp a callback <a class="el" href="namespace_a_p_i.html">API</a> can be used. <a class="el" href="protocol_the-p.html">The</a> function pointers of the receive and send callbacks are new arguments to the socket call. They are NULL, if no callback <a class="el" href="namespace_a_p_i.html">API</a> is used. <a class="el" href="protocol_the-p.html">The</a> <code>sb_threshold</code> specifies the amount of free space in the send socket buffer before the send function in the application is called. If a send callback function is specified and <code>sb_threshold</code> is 0, the function is called whenever there is room in the send socket buffer.</p>
<p>On success <code><a class="el" href="user__socket_8c.html#a687a015e27c2910886dd371596478209">usrsctp_socket()</a></code> returns the pointer to the new socket in the <code>struct socket</code> data type. It will be needed in all other system calls. In case of a failure NULL is returned and errno is set to the appropriate error code.</p>
<h3><a class="el" href="user__socket_8c.html#a260c6b58b2fdccdab064f0227decfdad">usrsctp_close()</a></h3>
<p><a class="el" href="protocol_the-p.html">The</a> function prototype of <code><a class="el" href="user__socket_8c.html#a260c6b58b2fdccdab064f0227decfdad">usrsctp_close()</a></code> is</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="user__socket_8c.html#a260c6b58b2fdccdab064f0227decfdad">usrsctp_close</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so)</div></div><!-- fragment --><p> Thus the only difference is the absence of a return code.</p>
<h2>Same Functionality as RFC 6458</h2>
<p><a class="el" href="protocol_the-p.html">The</a> following functions have the same functionality as their kernel pendants. There prototypes are described in the following subsections. For a detailed description please refer to <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>.</p>
<h3><a class="el" href="user__socket_8c.html#a514891b7a3999f423c9f73013ba22734">usrsctp_bind()</a></h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span></div><div class="line"><a class="code" href="user__socket_8c.html#a514891b7a3999f423c9f73013ba22734">usrsctp_bind</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so,</div><div class="line">             <span class="keyword">struct</span> sockaddr *addr,</div><div class="line">             socklen_t addrlen)</div></div><!-- fragment --><ul>
<li>so: Pointer to the socket as returned by <code><a class="el" href="user__socket_8c.html#a687a015e27c2910886dd371596478209">usrsctp_socket()</a></code>.</li>
<li>addr: <a class="el" href="protocol_the-p.html">The</a> address structure (<code>struct sockaddr_in</code> for an IPv4 address or <code>struct sockaddr_in6</code> for an IPv6 address).</li>
<li>addrlen: <a class="el" href="protocol_the-p.html">The</a> size of the address structure.</li>
</ul>
<p><code><a class="el" href="user__socket_8c.html#a514891b7a3999f423c9f73013ba22734">usrsctp_bind()</a></code> returns 0 on success and -1 in case of an error.</p>
<h3><a class="el" href="user__socket_8c.html#a20891be91b5d31e3b5a77bc20e95615b">usrsctp_listen()</a></h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span></div><div class="line"><a class="code" href="user__socket_8c.html#a20891be91b5d31e3b5a77bc20e95615b">usrsctp_listen</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so,</div><div class="line">               <span class="keywordtype">int</span> backlog)</div></div><!-- fragment --><ul>
<li>so: Pointer to the socket as returned by <code><a class="el" href="user__socket_8c.html#a687a015e27c2910886dd371596478209">usrsctp_socket()</a></code>.</li>
<li>backlog: If backlog is non-zero, enable listening, else disable listening.</li>
</ul>
<p><code><a class="el" href="user__socket_8c.html#a20891be91b5d31e3b5a77bc20e95615b">usrsctp_listen()</a></code> returns 0 on success and -1 in case of an error.</p>
<h3><a class="el" href="user__socket_8c.html#aaef30bbffb4234026add659b27c0e1a6">usrsctp_accept()</a></h3>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structsocket.html">socket</a> *</div><div class="line"><a class="code" href="user__socket_8c.html#aaef30bbffb4234026add659b27c0e1a6">usrsctp_accept</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so,</div><div class="line">               <span class="keyword">struct</span> sockaddr * addr,</div><div class="line">               socklen_t * addrlen)</div></div><!-- fragment --><ul>
<li>so: Pointer to the socket as returned by <code><a class="el" href="user__socket_8c.html#a687a015e27c2910886dd371596478209">usrsctp_socket()</a></code>.</li>
<li>addr: On return, the primary address of the peer (<code>struct sockaddr_in</code> for an IPv4 address or <code>struct sockaddr_in6</code> for an IPv6 address).</li>
<li>addrlen: Size of the returned address structure.</li>
</ul>
<p><code><a class="el" href="user__socket_8c.html#aaef30bbffb4234026add659b27c0e1a6">usrsctp_accept()</a></code> returns the accepted socket on success and NULL in case of an error.</p>
<h3><a class="el" href="user__socket_8c.html#a5920da8d4480e4a25bab69aa7ad965ab">usrsctp_connect()</a></h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span></div><div class="line"><a class="code" href="user__socket_8c.html#a5920da8d4480e4a25bab69aa7ad965ab">usrsctp_connect</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so,</div><div class="line">                <span class="keyword">struct</span> sockaddr *<a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2usr_2local_2include_2_a_n_g_l_e_2eglext_8h.html#aaced7cfc21e7d37775d6921bb8177239">name</a>,</div><div class="line">                socklen_t addrlen)</div></div><!-- fragment --><ul>
<li>so: Pointer to the socket as returned by <code><a class="el" href="user__socket_8c.html#a687a015e27c2910886dd371596478209">usrsctp_socket()</a></code>.</li>
<li>name: Address of the peer to connect to (<code>struct sockaddr_in</code> for an IPv4 address or <code>struct sockaddr_in6</code> for an IPv6 address).</li>
<li>addrlen: Size of the peer's address.</li>
</ul>
<p><a class="el" href="user__socket_8c.html#a5920da8d4480e4a25bab69aa7ad965ab">usrsctp_connect()</a> returns 0 on success and -1 in case of an error.</p>
<h3><a class="el" href="user__socket_8c.html#ad65a2f3f548d97476b842f2c76e71906">usrsctp_shutdown()</a></h3>
<div class="fragment"><div class="line"><span class="keywordtype">int</span></div><div class="line"><a class="code" href="user__socket_8c.html#ad65a2f3f548d97476b842f2c76e71906">usrsctp_shutdown</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so, <span class="keywordtype">int</span> how)</div></div><!-- fragment --><ul>
<li>so: Pointer to the socket of the association to be closed</li>
<li>how: Specifies the type of shutdown. <a class="el" href="protocol_the-p.html">The</a> values are as follows:<ul>
<li>SHUT_RD: Disables further receive operations. No SCTP protocol action is taken.</li>
<li>SHUT_WR: Disables further send operations, and initiates the SCTP shutdown sequence.</li>
<li>SHUT_RDWR: Disables further send and receive operations, and initiates the SCTP shutdown sequence.</li>
</ul>
</li>
</ul>
<p><code><a class="el" href="user__socket_8c.html#a20891be91b5d31e3b5a77bc20e95615b">usrsctp_listen()</a></code> returns 0 on success and -1 in case of an error.</p>
<h2>Sending and Receiving <a class="el" href="struct_data.html">Data</a></h2>
<p>Since the publication of <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a> there is only one function for sending and one for receiving that is not deprecated. Therefore, only these two are described here.</p>
<h3><a class="el" href="user__socket_8c.html#a5e925e8d8fd58f1dd4845b243baecfa4">usrsctp_sendv()</a></h3>
<div class="fragment"><div class="line">ssize_t</div><div class="line"><a class="code" href="user__socket_8c.html#a5e925e8d8fd58f1dd4845b243baecfa4">usrsctp_sendv</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so,</div><div class="line">              <span class="keyword">const</span> <span class="keywordtype">void</span> *data,</div><div class="line">              <span class="keywordtype">size_t</span> <a class="code" href="x509_8h.html#a70bf162ad7ddfc129bb6cbb646a0d3e0">len</a>,</div><div class="line">              <span class="keyword">struct</span> sockaddr *addrs,</div><div class="line">              <span class="keywordtype">int</span> addrcnt,</div><div class="line">              <span class="keywordtype">void</span> *<a class="code" href="namespaceplanet_1_1compat__logging.html#ac266fdaa533d5f3ef005a8415d1fc5f2">info</a>,</div><div class="line">              socklen_t infolen,</div><div class="line">              <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> infotype,</div><div class="line">              <span class="keywordtype">int</span> flags)</div></div><!-- fragment --><ul>
<li>so: <a class="el" href="protocol_the-p.html">The</a> socket to send data on.</li>
<li>data: As it is more convenient to send data in a buffer and not a <code>struct iovec</code> data structure, we chose to pass the data as a void pointer.</li>
<li>len: Length of the data.</li>
<li>addrs: In this version of usrsctp at most one destination address is supported. In the case of a connected socket, the parameter <code>addrs</code> can be set to NULL.</li>
<li>addrcnt: Number of addresses. As at most one address is supported, addrcnt is 0 if addrs is NULL and 1 otherwise.</li>
<li>info: Additional information for a message is stored in <code>void *info</code>. <a class="el" href="protocol_the-p.html">The</a> data types <code>struct <a class="el" href="structsctp__sndinfo.html">sctp_sndinfo</a></code>, <code>struct <a class="el" href="structsctp__prinfo.html">sctp_prinfo</a></code>, and <code>struct <a class="el" href="structsctp__sendv__spa.html">sctp_sendv_spa</a></code> are supported as defined in <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>. Support for <code>struct <a class="el" href="structsctp__authinfo.html">sctp_authinfo</a></code> is not implemented yet, therefore, errno is set EINVAL and -1 will be returned, if it is used.</li>
<li>infolen: Length of info in bytes.</li>
<li>infotype: Identifies the type of the information provided in info. Possible values are<ul>
<li>SCTP_SENDV_NOINFO</li>
<li>SCTP_SENDV_SNDINFO</li>
<li>SCTP_SENDV_PRINFO</li>
<li>SCTP_SENDV_SPA (For additional information please refer to <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>.)</li>
</ul>
</li>
<li>flags: Flags as described in <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>.</li>
</ul>
<p><code><a class="el" href="user__socket_8c.html#a5e925e8d8fd58f1dd4845b243baecfa4">usrsctp_sendv()</a></code> returns the number of bytes sent, or -1 if an error occurred. <a class="el" href="protocol_the-p.html">The</a> variable errno is then set appropriately.</p>
<h3><a class="el" href="user__socket_8c.html#a2e6c8b2a3abaf7f8784d8210a847abb6">usrsctp_recvv()</a></h3>
<div class="fragment"><div class="line">ssize_t</div><div class="line"><a class="code" href="user__socket_8c.html#a2e6c8b2a3abaf7f8784d8210a847abb6">usrsctp_recvv</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so,</div><div class="line">             <span class="keywordtype">void</span> *dbuf,</div><div class="line">             <span class="keywordtype">size_t</span> len,</div><div class="line">             <span class="keyword">struct</span> sockaddr *from,</div><div class="line">             socklen_t * fromlen,</div><div class="line">             <span class="keywordtype">void</span> *info,</div><div class="line">             socklen_t *infolen,</div><div class="line">             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *infotype,</div><div class="line">             <span class="keywordtype">int</span> *msg_flags)</div></div><!-- fragment --><ul>
<li>so: <a class="el" href="protocol_the-p.html">The</a> socket to receive data on.</li>
<li>dbuf: Analog to <code><a class="el" href="user__socket_8c.html#a5e925e8d8fd58f1dd4845b243baecfa4">usrsctp_sendv()</a></code> the data is returned in a buffer.</li>
<li>len: Length of the buffer in bytes.</li>
<li>from: <a class="el" href="struct_a.html">A</a> pointer to an address to be filled with the sender of the received message's address.</li>
<li>fromlen: An in/out parameter describing the from length.</li>
<li>info: <a class="el" href="struct_a.html">A</a> pointer to the buffer to hold the attributes of the received message. <a class="el" href="protocol_the-p.html">The</a> structure type of info is determined by the infotype parameter. <a class="el" href="protocol_the-p.html">The</a> attributes returned in <code>info</code> have to be handled in the same way as specified in <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>.</li>
<li>infolen: An in/out parameter describing the size of the info buffer.</li>
<li>infotype: On return, <code>*infotype</code> is set to the type of the info buffer. <a class="el" href="protocol_the-p.html">The</a> current defined values are<ul>
<li>SCTP_RECVV_NOINFO</li>
<li>SCTP_RECVV_RCVINFO</li>
<li>SCTP_RECVV_NXTINFO</li>
<li>SCTP_RECVV_RN (<a class="el" href="struct_a.html">A</a> detailed description is given in <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>)</li>
</ul>
</li>
<li>flags: <a class="el" href="struct_a.html">A</a> pointer to an integer to be filled with any message flags (e.g., <code>MSG_NOTIFICATION</code>). Note that this field is an in/out parameter. Options for the receive may also be passed into the value (e.g., <code>MSG_EOR</code>). Returning from the call, the flags' value will differ from its original value.</li>
</ul>
<p><code><a class="el" href="user__socket_8c.html#a2e6c8b2a3abaf7f8784d8210a847abb6">usrsctp_recvv()</a></code> returns the number of bytes sent, or -1 if an error occurred. <a class="el" href="protocol_the-p.html">The</a> variable errno is then set appropriately.</p>
<h2>Socket Options</h2>
<p>Socket options are used to change the default behavior of socket calls. Their behavior is specified in <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>. <a class="el" href="protocol_the-p.html">The</a> functions to get or set them are</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span></div><div class="line"><a class="code" href="user__socket_8c.html#a654b8450b702a458d8f7baad689c4ea9">usrsctp_getsockopt</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so,</div><div class="line">                     <span class="keywordtype">int</span> <a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2usr_2local_2include_2_a_n_g_l_e_2gl2_8h.html#abc60a79088789bd61297bf5f9ff500d1">level</a>,</div><div class="line">                     <span class="keywordtype">int</span> optname,</div><div class="line">                     <span class="keywordtype">void</span> *<a class="code" href="tsctp_8c.html#a8d07347e7a2e3f70ae8cb1a83a571ce9">optval</a>,</div><div class="line">                     socklen_t *optlen)</div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line"><span class="keywordtype">int</span></div><div class="line"><a class="code" href="user__socket_8c.html#ae2bcd493168619a35cea68e3618c5578">usrsctp_setsockopt</a>(<span class="keyword">struct</span> <a class="code" href="structsocket.html">socket</a> *so,</div><div class="line">                     <span class="keywordtype">int</span> level,</div><div class="line">                     <span class="keywordtype">int</span> optname,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">void</span> *optval,</div><div class="line">                     socklen_t optlen)</div></div><!-- fragment --><p>and the arguments are</p><ul>
<li>so: <a class="el" href="protocol_the-p.html">The</a> socket of type struct socket.</li>
<li>level: Set to IPPROTO_SCTP for all SCTP options.</li>
<li>optname: <a class="el" href="protocol_the-p.html">The</a> option name as specified in <a class="el" href="protocol_the-p.html">The</a> Socket Options table below.</li>
<li>optval: <a class="el" href="protocol_the-p.html">The</a> buffer to store the value of the option as specified in the second column of Socket Options below.</li>
<li>optlen: <a class="el" href="protocol_the-p.html">The</a> size of the buffer (or the length of the option returned in case of <code>usrsctp_getsockopt</code>).</li>
</ul>
<p>These functions return 0 on success and -1 in case of an error.</p>
<h3>Socket Options supported by usrsctp</h3>
<table class="doxtable">
<tr>
<th>Option </th><th>Datatype </th><th>r/w  </th></tr>
<tr>
<td>SCTP_RTOINFO </td><td>struct <a class="el" href="structsctp__rtoinfo.html">sctp_rtoinfo</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_ASSOCINFO </td><td>struct <a class="el" href="structsctp__assocparams.html">sctp_assocparams</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_INITMSG </td><td>struct <a class="el" href="structsctp__initmsg.html">sctp_initmsg</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_NODELAY </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_AUTOCLOSE </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_PRIMARY_ADDR </td><td>struct <a class="el" href="structsctp__setprim.html">sctp_setprim</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_ADAPTATION_LAYER </td><td>struct <a class="el" href="structsctp__setadaptation.html">sctp_setadaptation</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_DISABLE_FRAGMENTS </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_PEER_ADDR_PARAMS </td><td>struct <a class="el" href="structsctp__paddrparams.html">sctp_paddrparams</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_I_WANT_MAPPED_V4_ADDR </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_MAXSEG </td><td>struct <a class="el" href="structsctp__assoc__value.html">sctp_assoc_value</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_DELAYED_SACK </td><td>struct <a class="el" href="structsctp__sack__info.html">sctp_sack_info</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_FRAGMENT_INTERLEAVE </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_PARTIAL_DELIVERY_POINT </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_HMAC_IDENT </td><td>struct <a class="el" href="structsctp__hmacalgo.html">sctp_hmacalgo</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_AUTH_ACTIVE_KEY </td><td>struct <a class="el" href="structsctp__authkeyid.html">sctp_authkeyid</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_AUTO_ASCONF </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_MAX_BURST </td><td>struct <a class="el" href="structsctp__assoc__value.html">sctp_assoc_value</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_CONTEXT </td><td>struct <a class="el" href="structsctp__assoc__value.html">sctp_assoc_value</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_EXPLICIT_EOR </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_REUSE_PORT </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_EVENT </td><td>struct <a class="el" href="structsctp__event.html">sctp_event</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_RECVRCVINFO </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_RECVNXTINFO </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_DEFAULT_SNDINFO </td><td>struct <a class="el" href="structsctp__sndinfo.html">sctp_sndinfo</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_DEFAULT_PRINFO </td><td>struct <a class="el" href="structsctp__default__prinfo.html">sctp_default_prinfo</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_REMOTE_UDP_ENCAPS_PORT </td><td>int </td><td>r/w </td></tr>
<tr>
<td>SCTP_ENABLE_STREAM_RESET </td><td>struct <a class="el" href="structsctp__assoc__value.html">sctp_assoc_value</a> </td><td>r/w </td></tr>
<tr>
<td>SCTP_STATUS </td><td>struct <a class="el" href="structsctp__status.html">sctp_status</a> </td><td>r </td></tr>
<tr>
<td>SCTP_GET_PEER_ADDR_INFO </td><td>struct <a class="el" href="structsctp__paddrinfo.html">sctp_paddrinfo</a> </td><td>r </td></tr>
<tr>
<td>SCTP_PEER_AUTH_CHUNKS </td><td>struct <a class="el" href="structsctp__authchunks.html">sctp_authchunks</a> </td><td>r </td></tr>
<tr>
<td>SCTP_LOCAL_AUTH_CHUNKS </td><td>struct <a class="el" href="structsctp__authchunks.html">sctp_authchunks</a> </td><td>r </td></tr>
<tr>
<td>SCTP_GET_ASSOC_NUMBER </td><td>uint32_t </td><td>r </td></tr>
<tr>
<td>SCTP_GET_ASSOC_ID_LIST </td><td>struct <a class="el" href="structsctp__assoc__ids.html">sctp_assoc_ids</a> </td><td>r </td></tr>
<tr>
<td>SCTP_RESET_STREAMS </td><td>struct <a class="el" href="structsctp__reset__streams.html">sctp_reset_streams</a> </td><td>w </td></tr>
<tr>
<td>SCTP_RESET_ASSOC </td><td>struct sctp_assoc_t </td><td>w </td></tr>
<tr>
<td>SCTP_ADD_STREAMS </td><td>struct <a class="el" href="structsctp__add__streams.html">sctp_add_streams</a> </td><td>w </td></tr>
</table>
<p>Further usage details are described in <a href="tools.ietf.org/html/rfc6458">RFC 6458</a>, <a href="tools.ietf.org/html/rfc6525">RFC 6525</a>, and <a href="https://tools.ietf.org/html/draft-ietf-tsvwg-sctp-udp-encaps-03">draft-ietf-tsvwg-sctp-udp-encaps-03</a> (work in progress).</p>
<h2>Sysctl variables</h2>
<p>In kernel implementations like for instance FreeBSD, it is possible to change parameters in the operating system. These parameters are called sysctl variables.</p>
<p>In usrsctp applications can set or retrieve these variables with the functions </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> usrsctp_sysctl_set_ ## (<a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2_web_core_8framework_2_versions_2_a_2_privatc2dad1314081d5d61224d82bea996c93.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> <a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2usr_2local_2include_2_a_n_g_l_e_2eglext_8h.html#ad6103472bb51773301db1ff4a207ea3f">value</a>)</div></div><!-- fragment --><p> and </p><div class="fragment"><div class="line"><a class="code" href="_derived_data_2_web_kit_2_build_2_products_2_debug_2_web_core_8framework_2_versions_2_a_2_privatc2dad1314081d5d61224d82bea996c93.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> usrsctp_sysctl_get_ ## (<a class="code" href="_a_v_foundation_c_f_soft_linking_8h.html#a048848dadb8ead3df6561b53a3ef5219">void</a>)</div></div><!-- fragment --><p> respectively, where <code>##</code> stands for the name of the variable.</p>
<p>In the following paragraphs a short description of the parameters will be given.</p>
<h2>Manipulate Memory</h2>
<h4>usrsctp_sysctl_set_sctp_sendspace()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> space of the available send buffer can be changed from its default value of 262,144 bytes to a value between 0 and <code>2^32 - 1</code> bytes.</p>
<h4>usrsctp_sysctl_set_sctp_recvspace()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> space of the available receive buffer can be changed from its default value of 262,144 bytes to a value between 0 and <code>2^32 - 1</code> bytes.</p>
<h4>usrsctp_sysctl_set_sctp_hashtblsize()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> TCB (Thread Control Block) hash table sizes, i.e. the size of one TCB in the hash table, can be tuned between 1 and <code>2^32 - 1</code> bytes. <a class="el" href="protocol_the-p.html">The</a> default value is 1,024 bytes. <a class="el" href="struct_a.html">A</a> TCB contains for instance pointers to the socket, the endpoint, information about the association and some statistic data.</p>
<h4>usrsctp_sysctl_set_sctp_pcbtblsize()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> PCB (Protocol Control Block) hash table sizes, i.e. the size of one PCB in the hash table, can be tuned between 1 and <code>2^32 - 1</code> bytes. <a class="el" href="protocol_the-p.html">The</a> default value is 256 bytes. <a class="el" href="protocol_the-p.html">The</a> PCB contains all variables that characterize an endpoint.</p>
<h4>usrsctp_sysctl_set_sctp_system_free_resc_limit()</h4>
<p>This parameters tunes the maximum number of cached resources in the system. It can be set between 0 and <code>2^32 - 1</code>. <a class="el" href="protocol_the-p.html">The</a> default value is 1000.</p>
<h4>usrsctp_sysctl_set_sctp_asoc_free_resc_limit()</h4>
<p>This parameters tunes the maximum number of cached resources in an association. It can be set between 0 and <code>2^32 - 1</code>. <a class="el" href="protocol_the-p.html">The</a> default value is 10.</p>
<h4>usrsctp_sysctl_set_sctp_mbuf_threshold_count()</h4>
<p><a class="el" href="struct_data.html">Data</a> is stored in mbufs. Several mbufs can be chained together. <a class="el" href="protocol_the-p.html">The</a> maximum number of small mbufs in a chain can be set with this parameter, before an mbuf cluset is used. <a class="el" href="protocol_the-p.html">The</a> default is 5.</p>
<h4>usrsctp_sysctl_set_sctp_add_more_threshold()</h4>
<p>TBD This parameter configures the threshold below which more space should be added to a socket send buffer. <a class="el" href="protocol_the-p.html">The</a> default value is 1452 bytes.</p>
<h2>Configure RTO</h2>
<p><a class="el" href="protocol_the-p.html">The</a> retransmission timeout (RTO), i.e. the time that controls the retransmission of messages, has several parameters, that can be changed, for example to shorten the time, before a message is retransmitted. <a class="el" href="protocol_the-p.html">The</a> range of these parameters is between 0 and <code>2^32 - 1</code>ms.</p>
<h4>usrsctp_sysctl_set_sctp_rto_max_default()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> default value for the maximum retransmission timeout in ms is 60,000 (60secs).</p>
<h4>usrsctp_sysctl_set_sctp_rto_min_default()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> default value for the minimum retransmission timeout in ms is 1,000 (1sec).</p>
<h4>usrsctp_sysctl_set_sctp_rto_initial_default()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> default value for the initial retransmission timeout in ms is 3,000 (3sec). This value is only needed before the first calculation of a round trip time took place.</p>
<h4>usrsctp_sysctl_set_sctp_init_rto_max_default()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> default value for the maximum retransmission timeout for an INIT chunk in ms is 60,000 (60secs).</p>
<h2>Set Timers</h2>
<h4>usrsctp_sysctl_set_sctp_valid_cookie_life_default()</h4>
<p><a class="el" href="struct_a.html">A</a> cookie has a specified life time. If it expires the cookie is not valid any more and an ABORT is sent. <a class="el" href="protocol_the-p.html">The</a> default value in ms is 60,000 (60secs).</p>
<h4>usrsctp_sysctl_set_sctp_heartbeat_interval_default()</h4>
<p>Set the default time between two heartbeats. <a class="el" href="protocol_the-p.html">The</a> default is 30,000ms.</p>
<h4>usrsctp_sysctl_set_sctp_shutdown_guard_time_default()</h4>
<p>If a SHUTDOWN is not answered with a SHUTDOWN-ACK while the shutdown guard timer is still running, the association will be aborted after the default of 180secs.</p>
<h4>usrsctp_sysctl_set_sctp_pmtu_raise_time_default()</h4>
<p>TBD To set the size of the packets to the highest value possible, the maximum transfer unit (MTU) of the complete path has to be known. <a class="el" href="protocol_the-p.html">The</a> default time interval for the path mtu discovery is 600secs.</p>
<h4>usrsctp_sysctl_set_sctp_secret_lifetime_default()</h4>
<p>TBD <a class="el" href="protocol_the-p.html">The</a> default secret lifetime of a server is 3600secs.</p>
<h4>usrsctp_sysctl_set_sctp_vtag_time_wait()</h4>
<p>TBD Vtag time wait time, 0 disables it. Default: 60secs</p>
<h2>Set Failure Limits</h2>
<p>Transmissions and retransmissions of messages might fail. To protect the system against too many retransmissions, limits have to be defined.</p>
<h4>usrsctp_sysctl_set_sctp_init_rtx_max_default()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> default maximum number of retransmissions of an INIT chunks is 8, before an ABORT is sent.</p>
<h4>usrsctp_sysctl_set_sctp_assoc_rtx_max_default()</h4>
<p>This parameter sets the maximum number of failed retransmissions before the association is aborted. <a class="el" href="protocol_the-p.html">The</a> default vaule is 10.</p>
<h4>usrsctp_sysctl_set_sctp_path_rtx_max_default()</h4>
<p>This parameter sets the maximum number of path failures before the association is aborted. <a class="el" href="protocol_the-p.html">The</a> default value is 5. Notice that the number of paths multiplied by this value should be equal to <code>sctp_assoc_rtx_max_default</code>. That means that the default configuration is good for two paths.</p>
<h4>usrsctp_sysctl_set_sctp_max_retran_chunk()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> parameter configures how many times an unlucky chunk can be retransmitted before the association aborts. <a class="el" href="protocol_the-p.html">The</a> default is set to 30.</p>
<h4>usrsctp_sysctl_set_sctp_path_pf_threshold()</h4>
<p>TBD Default potentially failed threshold. Default: 65535</p>
<h4>usrsctp_sysctl_set_sctp_abort_if_one_2_one_hits_limit()</h4>
<p>TBD When one-2-one hits qlimit abort. Default: 0</p>
<h2>Control the Sending of SACKs</h2>
<h4>usrsctp_sysctl_set_sctp_sack_freq_default()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> SACK frequency defines the number of packets that are awaited, before a SACK is sent. <a class="el" href="protocol_the-p.html">The</a> default value is 2.</p>
<h4>usrsctp_sysctl_set_sctp_delayed_sack_time_default()</h4>
<p>As a SACK (Selective Acknowlegment) is sent after every other packet, a timer is set to send a SACK in case another packet does not arrive in due time. <a class="el" href="protocol_the-p.html">The</a> default value for this timer is 200ms.</p>
<h4>usrsctp_sysctl_set_sctp_strict_sacks()</h4>
<p>TBD This is a flag to turn the controlling of the coherence of SACKs on or off. <a class="el" href="protocol_the-p.html">The</a> default value is 1 (on).</p>
<h4>usrsctp_sysctl_set_sctp_nr_sack_on_off()</h4>
<p>If a slow hosts receives data on a lossy link it is possible that its receiver window is full and new data can only be accepted if one chunk with a higher TSN (Transmission Sequence Number) that has previously been acknowledged is dropped. As a consequence the sender has to store data, even if they have been acknowledged in case they have to be retransmitted. If this behavior is not necessary, non-renegable SACKs can be turned on. By default the use of non-renegable SACKs is turned off.</p>
<h4>usrsctp_sysctl_set_sctp_enable_sack_immediately()</h4>
<p>In some cases it is not desirable to wait for the SACK timer to expire before a SACK is sent. In these cases a bit called SACK-IMMEDIATELY (see <a href="https://tools.ietf.org/html/draft-tuexen-tsvwg-sctp-sack-immediately-09">draft-tuexen-tsvwg-sctp-sack-immediately-09</a>) can be set to provoke the instant sending of a SACK. <a class="el" href="protocol_the-p.html">The</a> default is to turn it off.</p>
<h4>usrsctp_sysctl_set_sctp_L2_abc_variable()</h4>
<p>TBD SCTP ABC max increase per SACK (L). Default: 1</p>
<h2>Change Max Burst</h2>
<p>Max burst defines the maximum number of packets that may be sent in one flight.</p>
<h4>usrsctp_sysctl_set_sctp_max_burst_default()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> default value for max burst is 0, which means that the number of packets sent as a flight is not limited by this parameter, but may be by another one, see the next paragraph.</p>
<h4>usrsctp_sysctl_set_sctp_use_cwnd_based_maxburst()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> use of max burst is based on the size of the congestion window (cwnd). This parameter is set by default.</p>
<h4>usrsctp_sysctl_set_sctp_hb_maxburst()</h4>
<p>Heartbeats are mostly used to verify a path. Their number can be limited. <a class="el" href="protocol_the-p.html">The</a> default is 4.</p>
<h4>usrsctp_sysctl_set_sctp_fr_max_burst_default()</h4>
<p>In the state of fast retransmission the number of packet bursts can be limited. <a class="el" href="protocol_the-p.html">The</a> default value is 4.</p>
<h2>Handle Chunks</h2>
<h4>usrsctp_sysctl_set_sctp_peer_chunk_oh()</h4>
<p>In order to keep track of the peer's advertised receiver window, the sender calculates the window by subtracting the amount of data sent. Yet, some OSs reduce the receiver window by the real space needed to store the data. This parameter sets the additional amount to debit the peer's receiver window per chunk sent. <a class="el" href="protocol_the-p.html">The</a> default value is 256, which is the value needed by FreeBSD.</p>
<h4>usrsctp_sysctl_set_sctp_max_chunks_on_queue()</h4>
<p>This parameter sets the maximum number of chunks that can be queued per association. <a class="el" href="protocol_the-p.html">The</a> default value is 512.</p>
<h4>usrsctp_sysctl_set_sctp_min_split_point()</h4>
<p>TBD <a class="el" href="protocol_the-p.html">The</a> minimum size when splitting a chunk is 2904 bytes by default.</p>
<h4>usrsctp_sysctl_set_sctp_chunkscale()</h4>
<p>TBD This parameter can be tuned for scaling of number of chunks and messages. <a class="el" href="protocol_the-p.html">The</a> default is10.</p>
<h4>usrsctp_sysctl_set_sctp_min_residual()</h4>
<p>TBD This parameter configures the minimum size of the residual data chunk in the second part of the split. <a class="el" href="protocol_the-p.html">The</a> default is 1452.</p>
<h2>Calculate RTT</h2>
<p><a class="el" href="protocol_the-p.html">The</a> calculation of the round trip time (RTT) depends on several parameters.</p>
<h4>usrsctp_sysctl_set_sctp_rttvar_bw()</h4>
<p>TBD Shift amount for bw smoothing on rtt calc. Default: 4</p>
<h4>usrsctp_sysctl_set_sctp_rttvar_rtt()</h4>
<p>TBD Shift amount for rtt smoothing on rtt calc. Default: 5</p>
<h4>usrsctp_sysctl_set_sctp_rttvar_eqret()</h4>
<p>TBD What to return when rtt and bw are unchanged. Default: 0</p>
<h2>Influence the Congestion Control</h2>
<p><a class="el" href="protocol_the-p.html">The</a> congestion control should protect the network against fast senders.</p>
<h4>usrsctp_sysctl_set_sctp_ecn_enable</h4>
<p>Explicit congestion notifications are turned on by default.</p>
<h4>usrsctp_sysctl_set_sctp_default_cc_module()</h4>
<p>This parameter sets the default algorithm for the congestion control. Default is 0, i.e. the one specified in <a href="http://tools.ietf.org/html/rfc4960">RFC 4960</a>.</p>
<h4>usrsctp_sysctl_set_sctp_initial_cwnd()</h4>
<p>Set the initial congestion window in MTUs. <a class="el" href="protocol_the-p.html">The</a> default is 3.</p>
<h4>usrsctp_sysctl_set_sctp_use_dccc_ecn()</h4>
<p>TBD Enable for RTCC CC datacenter ECN. Default: 1</p>
<h4>usrsctp_sysctl_set_sctp_steady_step()</h4>
<p>TBD How many the sames it takes to try step down of cwnd. Default: 20</p>
<h2>Configure AUTH and ADD-IP</h2>
<p>An important extension of SCTP is the dynamic address reconfiguration (see <a href="http://tools.ietf.org/html/rfc5061">RFC 5061</a>), also known as ADD-IP, which allows the changing of addresses during the lifetime of an association. For this feature the AUTH extension (see <a href="http://tools.ietf.org/html/rfc4895">RFC 4895</a>) is necessary.</p>
<h4>usrsctp_sysctl_set_sctp_auto_asconf()</h4>
<p>If SCTP Auto-ASCONF is enabled, the peer is informed automatically when a new address is added or removed. This feature is enabled by default.</p>
<h4>usrsctp_sysctl_set_sctp_multiple_asconfs()</h4>
<p>By default the sending of multiple ASCONFs is disabled.</p>
<h4>usrsctp_sysctl_set_sctp_auth_disable()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> use of AUTH, which is normally turned on, can be disabled by setting this parameter to 1.</p>
<h4>usrsctp_sysctl_set_sctp_asconf_auth_nochk()</h4>
<p>It is also possible to disable the requirement to use AUTH in conjunction with ADD-IP by setting this parameter to 1.</p>
<h2>Concurrent Multipath Transfer (CMT)</h2>
<p><a class="el" href="struct_a.html">A</a> prominent feature of SCTP is the possibility to use several addresses for the same association. One is the primary path, and the others are needed in case of a path failure. Using CMT the data is sent on several paths to enhance the throughput.</p>
<h4>usrsctp_sysctl_set_sctp_cmt_on_off()</h4>
<p>To turn CMT on, this parameter has to be set to 1.</p>
<h4>usrsctp_sysctl_set_sctp_cmt_use_dac()</h4>
<p>To use delayed acknowledgments with CMT this parameter has to be set to 1.</p>
<h4>usrsctp_sysctl_set_sctp_buffer_splitting()</h4>
<p>For CMT it makes sense to split the send and receive buffer to have shares for each path. By default buffer splitting is turned off.</p>
<h2>Network Address Translation (NAT)</h2>
<p>To be able to pass NAT boxes, the boxes have to handle SCTP packets in a specific way.</p>
<h4>usrsctp_sysctl_set_sctp_nat_friendly()</h4>
<p>SCTP NAT friendly operation. Default:1</p>
<h4>usrsctp_sysctl_set_sctp_inits_include_nat_friendly()</h4>
<p>Enable sending of the nat-friendly SCTP option on INITs. Default: 0</p>
<h4>usrsctp_sysctl_set_sctp_udp_tunneling_port()</h4>
<p>Set the SCTP/UDP tunneling port. Default: 9899</p>
<h2>SCTP Mobility</h2>
<h4>usrsctp_sysctl_set_sctp_mobility_base()</h4>
<p>TBD Enable SCTP base mobility. Default: 0</p>
<h4>usrsctp_sysctl_set_sctp_mobility_fasthandoff()</h4>
<p>TBD Enable SCTP fast handoff. default: 0</p>
<h2>Miscellaneous</h2>
<h4>usrsctp_sysctl_set_sctp_no_csum_on_loopback()</h4>
<p>Calculating the checksum for packets sent on loopback is turned off by default. To turn it on, set this parameter to 0.</p>
<h4>usrsctp_sysctl_set_sctp_nr_outgoing_streams_default()</h4>
<p><a class="el" href="protocol_the-p.html">The</a> peer is notified about the number of outgoing streams in the INIT or INIT-ACK chunk. <a class="el" href="protocol_the-p.html">The</a> default is 10.</p>
<h4>usrsctp_sysctl_set_sctp_do_drain()</h4>
<p>Determines whether SCTP should respond to the drain calls. Default: 1</p>
<h4>usrsctp_sysctl_set_sctp_strict_data_order()</h4>
<p>TBD Enforce strict data ordering, abort if control inside data. Default: 0</p>
<h4>usrsctp_sysctl_set_sctp_default_ss_module()</h4>
<p>Set the default stream scheduling module. Implemented modules are:</p><ul>
<li>SCTP_SS_DEFAULT</li>
<li>SCTP_SS_ROUND_ROBIN</li>
<li>SCTP_SS_ROUND_ROBIN_PACKET</li>
<li>SCTP_SS_PRIORITY</li>
<li>SCTP_SS_FAIR_BANDWITH</li>
<li>SCTP_SS_FIRST_COME</li>
</ul>
<h4>usrsctp_sysctl_set_sctp_default_frag_interleave()</h4>
<p>TBD Default fragment interleave level. Default: 1</p>
<h4>usrsctp_sysctl_set_sctp_blackhole()</h4>
<p>TBD Enable SCTP blackholing. Default: 0</p>
<h4>usrsctp_sysctl_set_sctp_logging_level()</h4>
<p>Set the logging level. <a class="el" href="protocol_the-p.html">The</a> default is 0.</p>
<h4>usrsctp_sysctl_set_sctp_debug_on()</h4>
<p>Turn debug output on or off. It is disabled by default. To obtain debug output, <code>SCTP_DEBUG</code> has to be set as a compile flag.</p>
<h3>sysctl variables supported by usrsctp</h3>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Meaning </th><th>Default Value  </th></tr>
<tr>
<td>sctp_sendspace </td><td>Send buffer space </td><td>1864135 </td></tr>
<tr>
<td>sctp_recvspace </td><td>Receive buffer space </td><td>1864135 </td></tr>
<tr>
<td>sctp_hashtblsize </td><td>Tunable for TCB hash table sizes </td><td>1024 </td></tr>
<tr>
<td>sctp_pcbtblsize </td><td>Tunable for PCB hash table sizes </td><td>256 </td></tr>
<tr>
<td>sctp_system_free_resc_limit </td><td>Cached resources in the system </td><td>1000 </td></tr>
<tr>
<td>sctp_asoc_free_resc_limit </td><td>Cashed resources in an association </td><td>10 </td></tr>
<tr>
<td>sctp_rto_max_default </td><td>Default value for RTO_max </td><td>60000ms </td></tr>
<tr>
<td>sctp_rto_min_default </td><td>Default value for RTO_min </td><td>1000ms </td></tr>
<tr>
<td>sctp_rto_initial_default </td><td>Default value for RTO_initial </td><td>3000ms </td></tr>
<tr>
<td>sctp_init_rto_max_default </td><td>Default value for the maximum RTO for sending an INIT </td><td>60000ms </td></tr>
<tr>
<td>sctp_valid_cookie_life_default </td><td>Valid cookie life time </td><td>60000ms </td></tr>
<tr>
<td>sctp_init_rtx_max_default </td><td>Maximum number of INIT retransmissions </td><td>8 </td></tr>
<tr>
<td>sctp_assoc_rtx_max_default </td><td>Maximum number of failed retransmissions before the association is aborted </td><td>10 </td></tr>
<tr>
<td>sctp_path_rtx_max_default </td><td>Maximum number of failed retransmissions before a path fails </td><td>5 </td></tr>
<tr>
<td>sctp_ecn_enable </td><td>Enabling explicit congestion notifications </td><td>1 </td></tr>
<tr>
<td>sctp_strict_sacks </td><td>Control the coherence of SACKs </td><td>1 </td></tr>
<tr>
<td>sctp_delayed_sack_time_default </td><td>Default delayed SACK timer </td><td>200ms </td></tr>
<tr>
<td>sctp_sack_freq_default </td><td>Default SACK frequency </td><td>2 </td></tr>
<tr>
<td>sctp_nr_sack_on_off </td><td>Turn non-renegable SACKs on or off </td><td>0 </td></tr>
<tr>
<td>sctp_enable_sack_immediately </td><td>Enable sending of the SACK-IMMEDIATELY bit </td><td>0 </td></tr>
<tr>
<td>sctp_no_csum_on_loopback </td><td>Enable the compilation of the checksum on packets sent on loopback </td><td>1 </td></tr>
<tr>
<td>sctp_peer_chunk_oh </td><td>Amount to debit peers rwnd per chunk sent </td><td>256 </td></tr>
<tr>
<td>sctp_max_burst_default </td><td>Default max burst for SCTP endpoints </td><td>0 </td></tr>
<tr>
<td>sctp_use_cwnd_based_maxburst </td><td>Use max burst based on the size of the congestion window </td><td>1 </td></tr>
<tr>
<td>sctp_hb_maxburst </td><td>Confirmation Heartbeat max burst </td><td>4 </td></tr>
<tr>
<td>sctp_max_chunks_on_queue </td><td>Default max chunks on queue per asoc </td><td>512 </td></tr>
<tr>
<td>sctp_min_split_point </td><td>Minimum size when splitting a chunk </td><td>2904 </td></tr>
<tr>
<td>sctp_chunkscale </td><td>Tunable for Scaling of number of chunks and messages </td><td>10 </td></tr>
<tr>
<td>sctp_mbuf_threshold_count </td><td>Maximum number of small mbufs in a chain </td><td>5 </td></tr>
<tr>
<td>sctp_heartbeat_interval_default </td><td>Deafult time between two Heartbeats </td><td>30000ms </td></tr>
<tr>
<td>sctp_pmtu_raise_time_default </td><td>Default PMTU raise timer </td><td>600secs </td></tr>
<tr>
<td>sctp_shutdown_guard_time_default </td><td>Default shutdown guard timer </td><td>180secs </td></tr>
<tr>
<td>sctp_secret_lifetime_default </td><td>Default secret lifetime </td><td>3600secs </td></tr>
<tr>
<td>sctp_add_more_threshold </td><td>Threshold when more space should be added to a socket send buffer </td><td>1452 </td></tr>
<tr>
<td>sctp_nr_outgoing_streams_default </td><td>Default number of outgoing streams </td><td>10 </td></tr>
<tr>
<td>sctp_cmt_on_off </td><td>Turn CMT on or off. </td><td>0 </td></tr>
<tr>
<td>sctp_cmt_use_dac </td><td>Use delayed acknowledgment for CMT </td><td>0 </td></tr>
<tr>
<td>sctp_fr_max_burst_default </td><td>Default max burst for SCTP endpoints when fast retransmitting </td><td>4 </td></tr>
<tr>
<td>sctp_auto_asconf </td><td>Enable SCTP Auto-ASCONF </td><td>1 </td></tr>
<tr>
<td>sctp_multiple_asconfs </td><td>Enable SCTP Muliple-ASCONFs </td><td>0 </td></tr>
<tr>
<td>sctp_asconf_auth_nochk </td><td>Disable SCTP ASCONF AUTH requirement </td><td>0 </td></tr>
<tr>
<td>sctp_auth_disable </td><td>Disable SCTP AUTH function </td><td>0 </td></tr>
<tr>
<td>sctp_nat_friendly </td><td>SCTP NAT friendly operation </td><td>1 </td></tr>
<tr>
<td>sctp_inits_include_nat_friendly </td><td>Enable sending of the nat-friendly SCTP option on INITs. </td><td>0 </td></tr>
<tr>
<td>sctp_udp_tunneling_port </td><td>Set the SCTP/UDP tunneling port </td><td>9899 </td></tr>
<tr>
<td>sctp_do_drain </td><td>Determines whether SCTP should respond to the drain calls </td><td>1 </td></tr>
<tr>
<td>sctp_abort_if_one_2_one_hits_limit </td><td>When one-2-one hits qlimit abort </td><td>0 </td></tr>
<tr>
<td>sctp_strict_data_order </td><td>Enforce strict data ordering, abort if control inside data </td><td>0 </td></tr>
<tr>
<td>sctp_min_residual </td><td>Minimum residual data chunk in second part of split </td><td>1452 </td></tr>
<tr>
<td>sctp_max_retran_chunk </td><td>Maximum times an unlucky chunk can be retransmitted before the association aborts </td><td>30 </td></tr>
<tr>
<td>sctp_default_cc_module </td><td>Default congestion control module </td><td>0 </td></tr>
<tr>
<td>sctp_default_ss_module </td><td>Default stream scheduling module </td><td>0 </td></tr>
<tr>
<td>sctp_default_frag_interleave </td><td>Default fragment interleave level </td><td>1 </td></tr>
<tr>
<td>sctp_mobility_base </td><td>Enable SCTP base mobility </td><td>0 </td></tr>
<tr>
<td>sctp_mobility_fasthandoff </td><td>Enable SCTP fast handoff </td><td>0 </td></tr>
<tr>
<td>sctp_L2_abc_variable </td><td>SCTP ABC max increase per SACK (L) </td><td>1 </td></tr>
<tr>
<td>sctp_vtag_time_wait </td><td>Vtag time wait time, 0 disables it. </td><td>60secs </td></tr>
<tr>
<td>sctp_blackhole </td><td>Enable SCTP blackholing </td><td>0 </td></tr>
<tr>
<td>sctp_path_pf_threshold </td><td>Default potentially failed threshold </td><td>65535 </td></tr>
<tr>
<td>sctp_rttvar_bw </td><td>Shift amount for bw smoothing on rtt calc </td><td>4 </td></tr>
<tr>
<td>sctp_rttvar_rtt </td><td>Shift amount for rtt smoothing on rtt calc </td><td>5 </td></tr>
<tr>
<td>sctp_rttvar_eqret </td><td>What to return when rtt and bw are unchanged </td><td>0 </td></tr>
<tr>
<td>sctp_steady_step </td><td>How many the sames it takes to try step down of cwnd </td><td>20 </td></tr>
<tr>
<td>sctp_use_dccc_ecn </td><td>Enable for RTCC CC datacenter ECN </td><td>1 </td></tr>
<tr>
<td>sctp_buffer_splitting </td><td>Enable send/receive buffer splitting </td><td>0 </td></tr>
<tr>
<td>sctp_initial_cwnd </td><td>Initial congestion window in MTUs </td><td>3 </td></tr>
<tr>
<td>sctp_logging_level </td><td>Logging level </td><td>0 </td></tr>
<tr>
<td>sctp_debug_on </td><td>Turns debug output on or off. </td><td>0 </td></tr>
</table>
<h2>Examples</h2>
<p>See <a href="https://github.com/sctplab/usrsctp/tree/master/programs">https://github.com/sctplab/usrsctp/tree/master/programs</a></p>
<h2>References</h2>
<h4>SCTP</h4>
<p>R. Stewart: <code>Stream Control Transmission Protocol</code>. <a href="http://tools.ietf.org/html/rfc4960">RFC 4960</a>, September 2007.</p>
<h4>auth</h4>
<p>M. Tüxen, R. Stewart, P. Lei, and <a class="el" href="class_e.html">E</a>. Rescorla: <code>Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)</code>. <a href="http://tools.ietf.org/html/rfc4895">RFC 4895</a>, August 2007.</p>
<h4>addip</h4>
<p>R. Stewart, Q. Xie, M. Tüxen, S. Maruyama, and M. Kozuka: <code>Stream Control Transmission Protocol (SCTP) Dynamic Address Reconfiguration</code>. <a href="http://tools.ietf.org/html/rfc5061">RFC 5061</a>, September 2007.</p>
<h4>socketAPI</h4>
<p>R. Stewart, M. Tüxen, K. Poon, and V. Yasevich: <code>Sockets <a class="el" href="namespace_a_p_i.html">API</a> Extensions for the Stream Control Transmission Protocol (SCTP)</code>. <a href="http://tools.ietf.org/html/rfc6458">RFC 6458</a>, Dezember 2011.</p>
<h4>streamReset</h4>
<p>R. Stewart, M. Tüxen, and P. Lei: <code>Stream Control Transmission Protocol (SCTP) Stream Reconfiguration</code>. <a href="http://tools.ietf.org/html/rfc6525">RFC 6525</a>, February 2012.</p>
<h4>udpencaps</h4>
<p>M. Tüxen and R. Stewart <code>UDP Encapsulation of Stream Control Transmission Protocol (SCTP) Packets for End-Host to End-Host Communication</code> <a href="https://tools.ietf.org/html/rfc6951">RFC 6951</a>, May 2013.</p>
<h4>sack-imm</h4>
<p>M. Tüxen, <a class="el" href="class_i.html">I</a>. Rüngeler, and R. Stewart: <code>SACK-IMMEDIATELY Extension for the Stream Control Transmission Protocol</code> <a href="https://tools.ietf.org/html/rfc7053">RFC 7053</a>, November 2013. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
