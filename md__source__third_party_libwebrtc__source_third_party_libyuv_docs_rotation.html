<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>webkit: Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">webkit
   &#160;<span id="projectnumber">2cdf99a9e3038c7e01b3c37e8ad903ecbe5eecf1</span>
   </div>
   <div id="projectbrief">https://github.com/WebKit/webkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Rotation by multiplies of 90 degrees allows mobile devices to rotate webcams from landscape to portrait. <a class="el" href="protocol_the-p.html">The</a> higher level functions ConvertToI420 and ConvertToARGB allow rotation of any format. Optimized functionality is supported for I420, ARGB, NV12 and NV21.</p>
<h1>ConvertToI420</h1>
<pre class="fragment">int ConvertToI420(const uint8* src_frame, size_t src_size,
                  uint8* dst_y, int dst_stride_y,
                  uint8* dst_u, int dst_stride_u,
                  uint8* dst_v, int dst_stride_v,
                  int crop_x, int crop_y,
                  int src_width, int src_height,
                  int crop_width, int crop_height,
                  enum RotationMode rotation,
                  uint32 format);
</pre><p>This function crops, converts, and rotates. You should think of it in that order.</p><ul>
<li>Crops the original image, which is src_width x src_height, to crop_width x crop_height. At this point the image is still not rotated.</li>
<li>Converts the cropped region to I420. Supports inverted source for src_height negative.</li>
<li>Rotates by 90, 180 or 270 degrees. <a class="el" href="protocol_the-p.html">The</a> buffer the caller provides should account for rotation. Be especially important to get stride of the destination correct.</li>
</ul>
<p>e.g. 640 x 480 NV12 captured<br />
 Crop to 640 x 360<br />
 Rotate by 90 degrees to 360 x 640.<br />
 Caller passes stride of 360 for Y and 360 / 2 for U and V.<br />
 Caller passes crop_width of 640, crop_height of 360.<br />
</p>
<h1>ConvertToARGB</h1>
<pre class="fragment">int ConvertToARGB(const uint8* src_frame, size_t src_size,
                  uint8* dst_argb, int dst_stride_argb,
                  int crop_x, int crop_y,
                  int src_width, int src_height,
                  int crop_width, int crop_height,
                  enum RotationMode rotation,
                  uint32 format);
</pre><p>Same as I420, but implementation is less optimized - reads columns and writes rows, 16 bytes at a time.</p>
<h1>I420Rotate</h1>
<pre class="fragment">int I420Rotate(const uint8* src_y, int src_stride_y,
               const uint8* src_u, int src_stride_u,
               const uint8* src_v, int src_stride_v,
               uint8* dst_y, int dst_stride_y,
               uint8* dst_u, int dst_stride_u,
               uint8* dst_v, int dst_stride_v,
               int src_width, int src_height, enum RotationMode mode);
</pre><p>Destination is rotated, so pass dst_stride_y etc that consider rotation.<br />
 Rotate by 180 can be done in place, but 90 and 270 can not.</p>
<p>Implementation (Neon/SSE2) uses 8 x 8 block transpose, so best efficiency is with sizes and pointers that are aligned to 8.</p>
<p>Cropping can be achieved by adjusting the src_y/u/v pointers and src_width, src_height.</p>
<p>Lower level plane functions are provided, allowing other planar formats to be rotated. (e.g. I444)</p>
<p>For other planar YUV formats (I444, I422, I411, I400, NV16, NV24), the planar functions are exposed and can be called directly</p>
<pre class="fragment">// Rotate a plane by 0, 90, 180, or 270.
int RotatePlane(const uint8* src, int src_stride,
                uint8* dst, int dst_stride,
                int src_width, int src_height, enum RotationMode mode);
</pre><h1>ARGBRotate</h1>
<pre class="fragment">LIBYUV_API
int ARGBRotate(const uint8* src_argb, int src_stride_argb,
               uint8* dst_argb, int dst_stride_argb,
               int src_width, int src_height, enum RotationMode mode);
</pre><p>Same as I420, but implementation is less optimized - reads columns and writes rows.</p>
<p>Rotate by 90, or any angle, can be achieved using ARGBAffine.</p>
<h1>Mirror - Horizontal Flip</h1>
<p>Mirror functions for horizontally flipping an image, which can be useful for 'self view' of a webcam. </p><pre class="fragment">int I420Mirror(const uint8* src_y, int src_stride_y,
               const uint8* src_u, int src_stride_u,
               const uint8* src_v, int src_stride_v,
               uint8* dst_y, int dst_stride_y,
               uint8* dst_u, int dst_stride_u,
               uint8* dst_v, int dst_stride_v,
               int width, int height);
int ARGBMirror(const uint8* src_argb, int src_stride_argb,
               uint8* dst_argb, int dst_stride_argb,
               int width, int height);
</pre><p>Mirror functionality can also be achieved with the I420Scale and ARGBScale functions by passing negative width and/or height.</p>
<h1>Invert - Vertical Flip</h1>
<p>Inverting can be achieved with almost any libyuv function by passing a negative source height.</p>
<p>I420Mirror and ARGBMirror can also be used to rotate by 180 degrees by passing a negative height. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
