<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>webkit: Protocol Buffers in Swift</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">webkit
   &#160;<span id="projectnumber">2cdf99a9e3038c7e01b3c37e8ad903ecbe5eecf1</span>
   </div>
   <div id="projectbrief">https://github.com/WebKit/webkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Protocol Buffers in Swift </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Objective</h2>
<p>This document describes the user-facing <a class="el" href="namespace_a_p_i.html">API</a> and internal implementation of proto2 and proto3 messages in Apple’s Swift programming language.</p>
<p>One of the key goals of protobufs is to provide idiomatic APIs for each language. In that vein, <b>interoperability with Objective-C is a non-goal of this proposal.</b> Protobuf users who need to pass messages between Objective-C and Swift code in the same application should use the existing Objective-C proto library. <a class="el" href="protocol_the-p.html">The</a> goal of the effort described here is to provide an <a class="el" href="namespace_a_p_i.html">API</a> for protobuf messages that uses features specific to Swift—optional types, algebraic enumerated types, value types, and so forth—in a natural way that will delight, rather than surprise, users of the language.</p>
<h2>Naming</h2>
<ul>
<li>By convention, both typical protobuf message names and Swift structs/classes are <code>UpperCamelCase</code>, so for most messages, the name of a message can be the same as the name of its generated type. (However, see the discussion below about prefixes under <a href="#packages">Packages</a>.)</li>
<li>Enum cases in protobufs typically are <code>UPPERCASE_WITH_UNDERSCORES</code>, whereas in Swift they are <code>lowerCamelCase</code> (as of the Swift 3 <a class="el" href="namespace_a_p_i.html">API</a> design guidelines). We will transform the names to match Swift convention, using a whitelist similar to the Objective-C compiler plugin to handle commonly used acronyms.</li>
<li>Typical fields in proto messages are <code>lowercase_with_underscores</code>, while in Swift they are <code>lowerCamelCase</code>. We will transform the names to match Swift convention by removing the underscores and uppercasing the subsequent letter.</li>
</ul>
<h2>Swift reserved words</h2>
<p>Swift has a large set of reserved words—some always reserved and some contextually reserved (that is, they can be used as identifiers in contexts where they would not be confused). As of Swift 2.2, the set of always-reserved words is:</p>
<div class="fragment"><div class="line">_, #available, #column, #else, #elseif, #endif, #file, #function, #if, #line,</div><div class="line">#selector, as, associatedtype, break, case, catch, class, continue, default,</div><div class="line">defer, deinit, do, dynamicType, else, enum, extension, fallthrough, false, for,</div><div class="line">func, guard, if, import, in, init, inout, internal, is, let, nil, operator,</div><div class="line">private, protocol, public, repeat, rethrows, return, self, Self, static,</div><div class="line">struct, subscript, super, switch, throw, throws, true, try, typealias, var,</div><div class="line">where, while</div></div><!-- fragment --><p><a class="el" href="protocol_the-p.html">The</a> set of contextually reserved words is:</p>
<div class="fragment"><div class="line">associativity, convenience, dynamic, didSet, final, get, infix, indirect,</div><div class="line">lazy, left, mutating, none, nonmutating, optional, override, postfix,</div><div class="line">precedence, prefix, Protocol, required, right, set, Type, unowned, weak,</div><div class="line">willSet</div></div><!-- fragment --><p>It is possible to use any reserved word as an identifier by escaping it with backticks (for example, <code>let `class` = 5</code>). Other name-mangling schemes would require us to transform the names themselves (for example, by appending an underscore), which requires us to then ensure that the new name does not collide with something else in the same namespace.</p>
<p>While the backtick feature may not be widely known by all Swift developers, a small amount of user education can address this and it seems like the best approach. We can unconditionally surround all property names with backticks to simplify generation.</p>
<p>Some remapping will still be required, though, to avoid collisions between generated properties and the names of methods and properties defined in the base protocol/implementation of messages.</p>
<h1>Features of Protocol Buffers</h1>
<p>This section describes how the features of the protocol buffer syntaxes (proto2 and proto3) map to features in Swift—what the code generated from a proto will look like, and how it will be implemented in the underlying library.</p>
<h2>Packages</h2>
<p>Modules are the main form of namespacing in Swift, but they are not declared using syntactic constructs like namespaces in C++ or packages in Java. Instead, they are tied to build targets in Xcode (or, in the future with open-source Swift, declarations in a Swift Package Manager manifest). They also do not easily support nesting submodules (Clang module maps support this, but pure Swift does not yet provide a way to define submodules).</p>
<p>We will generate types with fully-qualified underscore-delimited names. For example, a message <code>Baz</code> in package <code>foo.bar</code> would generate a struct named <code>Foo_Bar_Baz</code>. For each fully-qualified proto message, there will be exactly one unique type symbol emitted in the generated binary.</p>
<p>Users are likely to balk at the ugliness of underscore-delimited names for every generated type. To improve upon this situation, we will add a new string file level option, <code>swift_package_typealias</code>, that can be added to <code>.proto</code> files. When present, this will cause <code>typealias</code>es to be added to the generated Swift messages that replace the package name prefix with the provided string. For example, the following <code>.proto</code> file:</p>
<div class="fragment"><div class="line">option swift_package_typealias = &quot;FBP&quot;;</div><div class="line">package foo.bar;</div><div class="line"></div><div class="line">message Baz {</div><div class="line">  // Message fields</div><div class="line">}</div></div><!-- fragment --><p>would generate the following Swift source:</p>
<div class="fragment"><div class="line">public struct Foo_Bar_Baz {</div><div class="line">  // Message fields and other methods</div><div class="line">}</div><div class="line"></div><div class="line">typealias FBPBaz = Foo_Bar_Baz</div></div><!-- fragment --><p>It should be noted that this type alias is recorded in the generated <code>.swiftmodule</code> so that code importing the module can refer to it, but it does not cause a new symbol to be generated in the compiled binary (i.e., we do not risk compiled size bloat by adding <code>typealias</code>es for every type).</p>
<p>Other strategies to handle packages that were considered and rejected can be found in <a href="#appendix-a-rejected-strategies-to-handle-packages">Appendix A</a>.</p>
<h2><a class="el" href="namespace_messages.html">Messages</a></h2>
<p>Proto messages are natural value types and we will generate messages as structs instead of classes. Users will benefit from Swift’s built-in behavior with regard to mutability. We will define a <code>ProtoMessage</code> protocol that defines the common methods and properties for all messages (such as serialization) and also lets users treat messages polymorphically. Any shared method implementations that do not differ between individual messages can be implemented in a protocol extension.</p>
<p><a class="el" href="protocol_the-p.html">The</a> backing storage itself for fields of a message will be managed by a <code>ProtoFieldStorage</code> type that uses an internal dictionary keyed by field number, and whose values are the value of the field with that number (up-cast to Swift’s <code>Any</code> type). This class will provide type-safe getters and setters so that generated messages can manipulate this storage, and core serialization logic will live here as well. Furthermore, factoring the storage out into a separate type, rather than inlining the fields as stored properties in the message itself, lets us implement copy-on-write efficiently to support passing around large messages. (Furthermore, because the messages themselves are value types, inlining fields is not possible if the fields are submessages of the same type, or a type that eventually includes a submessage of the same type.)</p>
<h3>Required fields (proto2 only)</h3>
<p>Required fields in proto2 messages seem like they could be naturally represented by non-optional properties in Swift, but this presents some problems/concerns.</p>
<p>Serialization APIs permit partial serialization, which allows required fields to remain unset. Furthermore, other language APIs still provide <code>has*</code> and <code>clear*</code> methods for required fields, and knowing whether a property has a value when the message is in memory is still useful.</p>
<p>For example, an e-mail draft message may have the “to” address required on the wire, but when the user constructs it in memory, it doesn’t make sense to force a value until they provide one. We only want to force a value to be present when the message is serialized to the wire. Using non-optional properties prevents this use case, and makes client usage awkward because the user would be forced to select a sentinel or placeholder value for any required fields at the time the message was created.</p>
<h3>Default values</h3>
<p>In proto2, fields can have a default value specified that may be a value other than the default value for its corresponding language type (for example, a default value of 5 instead of 0 for an integer). When reading a field that is not explicitly set, the user expects to get that value. This makes Swift optionals (i.e., <code>Foo?</code>) unsuitable for fields in general. Unfortunately, we cannot implement our own “enhanced optional” type without severely complicating usage (Swift’s use of type inference and its lack of implicit conversions would require manual unwrapping of every property value).</p>
<p>Instead, we can use <b>implicitly unwrapped optionals.</b> For example, a property generated for a field of type <code>int32</code> would have Swift type <code>Int32!</code>. These properties would behave with the following characteristics, which mirror the nil-resettable properties used elsewhere in Apple’s SDKs (for example, <code>UIView.tintColor</code>):</p>
<ul>
<li>Assigning a non-nil value to a property sets the field to that value.</li>
<li>Assigning nil to a property clears the field (its internal representation is nilled out).</li>
<li>Reading the value of a property returns its value if it is set, or returns its default value if it is not set. Reading a property never returns nil.</li>
</ul>
<p><a class="el" href="protocol_the-p.html">The</a> final point in the list above implies that the optional cannot be checked to determine if the field is set to a value other than its default: it will never be nil. Instead, we must provide <code>has*</code> methods for each field to allow the user to check this. These methods will be public in proto2. In proto3, these methods will be private (if generated at all), since the user can test the returned value against the zero value for that type.</p>
<h3>Autocreation of nested messages</h3>
<p>For convenience, dotting into an unset field representing a nested message will return an instance of that message with default values. As in the Objective-C implementation, this does not actually cause the field to be set until the returned message is mutated. Fortunately, thanks to the way mutability of value types is implemented in Swift, the language automatically handles the reassignment-on-mutation for us. <a class="el" href="struct_a.html">A</a> static singleton instance containing default values can be associated with each message that can be returned when reading, so copies are only made by the Swift runtime when mutation occurs. For example, given the following proto:</p>
<div class="fragment"><div class="line">message Node {</div><div class="line">  Node child = 1;</div><div class="line">  string value = 2 [default = &quot;foo&quot;];</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="protocol_the-p.html">The</a> following Swift code would act as commented, where setting deeply nested properties causes the copies and mutations to occur as the assignment statement is unwound:</p>
<div class="fragment"><div class="line">var node = Node()</div><div class="line"></div><div class="line">let s = node.child.child.value</div><div class="line">// 1. node.child returns the &quot;default Node&quot;.</div><div class="line">// 2. Reading .child on the result of (1) returns the same default Node.</div><div class="line">// 3. Reading .value on the result of (2) returns the default value &quot;foo&quot;.</div><div class="line"></div><div class="line">node.child.child.value = &quot;bar&quot;</div><div class="line">// 4. Setting .value on the default Node causes a copy to be made and sets</div><div class="line">//    the property on that copy. Subsequently, the language updates the</div><div class="line">//    value of &quot;node.child.child&quot; to point to that copy.</div><div class="line">// 5. Updating &quot;node.child.child&quot; in (4) requires another copy, because</div><div class="line">//    &quot;node.child&quot; was also the instance of the default node. The copy is</div><div class="line">//    assigned back to &quot;node.child&quot;.</div><div class="line">// 6. Setting &quot;node.child&quot; in (5) is a simple value reassignment, since</div><div class="line">//    &quot;node&quot; is a mutable var.</div></div><!-- fragment --><p>In other words, the generated messages do not internally have to manage parental relationships to backfill the appropriate properties on mutation. Swift provides this for free.</p>
<h2>Scalar value fields</h2>
<p>Proto scalar value fields will map to Swift types in the following way:</p>
<table class="doxtable">
<tr>
<th>.proto Type </th><th>Swift Type  </th></tr>
<tr>
<td><code>double</code> </td><td><code>Double</code> </td></tr>
<tr>
<td><code>float</code> </td><td><code>Float</code> </td></tr>
<tr>
<td><code>int32</code> </td><td><code>Int32</code> </td></tr>
<tr>
<td><code>int64</code> </td><td><code>Int64</code> </td></tr>
<tr>
<td><code>uint32</code> </td><td><code>UInt32</code> </td></tr>
<tr>
<td><code>uint64</code> </td><td><code>UInt64</code> </td></tr>
<tr>
<td><code>sint32</code> </td><td><code>Int32</code> </td></tr>
<tr>
<td><code>sint64</code> </td><td><code>Int64</code> </td></tr>
<tr>
<td><code>fixed32</code> </td><td><code>UInt32</code> </td></tr>
<tr>
<td><code>fixed64</code> </td><td><code>UInt64</code> </td></tr>
<tr>
<td><code>sfixed32</code> </td><td><code>Int32</code> </td></tr>
<tr>
<td><code>sfixed64</code> </td><td><code>Int64</code> </td></tr>
<tr>
<td><code>bool</code> </td><td><code><a class="el" href="struct_bool.html">Bool</a></code> </td></tr>
<tr>
<td><code>string</code> </td><td><code>String</code> </td></tr>
<tr>
<td><code>bytes</code> </td><td><code>Foundation.NSData</code> </td></tr>
</table>
<p><a class="el" href="protocol_the-p.html">The</a> proto spec defines a number of integral types that map to the same Swift type; for example, <code>intXX</code>, <code>sintXX</code>, and <code>sfixedXX</code> are all signed integers, and <code>uintXX</code> and <code>fixedXX</code> are both unsigned integers. No other language implementation distinguishes these further, so we do not do so either. <a class="el" href="protocol_the-p.html">The</a> rationale is that the various types only serve to distinguish how the value is <b>encoded on the wire</b>; once loaded in memory, the user is not concerned about these variations.</p>
<p>Swift’s lack of implicit conversions among types will make it slightly annoying to use these types in a context expecting an <code>Int</code>, or vice-versa, but since this is a data-interchange format with explicitly-sized fields, we should not hide that information from the user. Users will have to explicitly write <code>Int(message.myField)</code>, for example.</p>
<h2>Embedded message fields</h2>
<p>Embedded message fields can be represented using an optional variable of the generated message type. Thus, the message</p>
<div class="fragment"><div class="line">message Foo {</div><div class="line">  Bar bar = 1;</div><div class="line">}</div></div><!-- fragment --><p>would be represented in Swift as</p>
<div class="fragment"><div class="line">public struct Foo: ProtoMessage {</div><div class="line">  public var bar: Bar! {</div><div class="line">    get { ... }</div><div class="line">    set { ... }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>If the user explicitly sets <code>bar</code> to nil, or if it was never set when read from the wire, retrieving the value of <code>bar</code> would return a default, statically allocated instance of <code>Bar</code> containing default values for its fields. This achieves the desired behavior for default values in the same way that scalar fields are designed, and also allows users to deep-drill into complex object graphs to get or set fields without checking for nil at each step.</p>
<h2>Enum fields</h2>
<p><a class="el" href="protocol_the-p.html">The</a> design and implementation of enum fields will differ somewhat drastically depending on whether the message being generated is a proto2 or proto3 message.</p>
<h3>proto2 enums</h3>
<p>For proto2, we do not need to be concerned about unknown enum values, so we can use the simple raw-value enum syntax provided by Swift. So the following enum in proto2:</p>
<div class="fragment"><div class="line">enum ContentType {</div><div class="line">  TEXT = 0;</div><div class="line">  IMAGE = 1;</div><div class="line">}</div></div><!-- fragment --><p>would become this Swift enum:</p>
<div class="fragment"><div class="line">public enum ContentType: Int32, NilLiteralConvertible {</div><div class="line">  case text = 0</div><div class="line">  case image = 1</div><div class="line"></div><div class="line">  public init(nilLiteral: ()) {</div><div class="line">    self = .text</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>See below for the discussion about <code>NilLiteralConvertible</code>.</p>
<h3>proto3 enums</h3>
<p>For proto3, we need to be able to preserve unknown enum values that may come across the wire so that they can be written back if unmodified. We can accomplish this in Swift by using a case with an associated value for unknowns. So the following enum in proto3:</p>
<div class="fragment"><div class="line">enum ContentType {</div><div class="line">  TEXT = 0;</div><div class="line">  IMAGE = 1;</div><div class="line">}</div></div><!-- fragment --><p>would become this Swift enum:</p>
<div class="fragment"><div class="line">public enum ContentType: RawRepresentable, NilLiteralConvertible {</div><div class="line">  case text</div><div class="line">  case image</div><div class="line">  case UNKNOWN_VALUE(Int32)</div><div class="line"></div><div class="line">  public typealias RawValue = Int32</div><div class="line"></div><div class="line">  public init(nilLiteral: ()) {</div><div class="line">    self = .text</div><div class="line">  }</div><div class="line"></div><div class="line">  public init(rawValue: RawValue) {</div><div class="line">    switch rawValue {</div><div class="line">      case 0: self = .text</div><div class="line">      case 1: self = .image</div><div class="line">      default: self = .UNKNOWN_VALUE(rawValue)</div><div class="line">  }</div><div class="line"></div><div class="line">  public var rawValue: RawValue {</div><div class="line">    switch self {</div><div class="line">      case .text: return 0</div><div class="line">      case .image: return 1</div><div class="line">      case .UNKNOWN_VALUE(let value): return value</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>Note that the use of a parameterized case prevents us from inheriting from the raw <code>Int32</code> type; Swift does not allow an enum with a raw type to have cases with arguments. Instead, we must implement the raw value initializer and computed property manually. <a class="el" href="protocol_the-p.html">The</a> <code>UNKNOWN_VALUE</code> case is explicitly chosen to be "ugly" so that it stands out and does not conflict with other possible case names.</p>
<p>Using this approach, proto3 consumers must always have a default case or handle the <code>.UNKNOWN_VALUE</code> case to satisfy case exhaustion in a switch statement; the Swift compiler considers it an error if switch statements are not exhaustive.</p>
<h3>NilLiteralConvertible conformance</h3>
<p>This is required to clean up the usage of enum-typed properties in switch statements. Unlike other field types, enum properties cannot be implicitly-unwrapped optionals without requiring that uses in switch statements be explicitly unwrapped. For example, if we consider a message with the enum above, this usage will fail to compile:</p>
<div class="fragment"><div class="line">// Without NilLiteralConvertible conformance on ContentType</div><div class="line">public struct SomeMessage: ProtoMessage {</div><div class="line">  public var contentType: ContentType! { ... }</div><div class="line">}</div><div class="line"></div><div class="line">// ERROR: no case named text or image</div><div class="line">switch someMessage.contentType {</div><div class="line">  case .text: { ... }</div><div class="line">  case .image: { ... }</div><div class="line">}</div></div><!-- fragment --><p>Even though our implementation guarantees that <code>contentType</code> will never be nil, if it is an optional type, its cases would be <code>some</code> and <code>none</code>, not the cases of the underlying enum type. In order to use it in this context, the user must write <code>someMessage.contentType!</code> in their switch statement.</p>
<p>Making the enum itself <code>NilLiteralConvertible</code> permits us to make the property non-optional, so the user can still set it to nil to clear it (i.e., reset it to its default value), while eliminating the need to explicitly unwrap it in a switch statement.</p>
<div class="fragment"><div class="line">// With NilLiteralConvertible conformance on ContentType</div><div class="line">public struct SomeMessage: ProtoMessage {</div><div class="line">  // Note that the property type is no longer optional</div><div class="line">  public var contentType: ContentType { ... }</div><div class="line">}</div><div class="line"></div><div class="line">// OK: Compiles and runs as expected</div><div class="line">switch someMessage.contentType {</div><div class="line">  case .text: { ... }</div><div class="line">  case .image: { ... }</div><div class="line">}</div><div class="line"></div><div class="line">// The enum can be reset to its default value this way</div><div class="line">someMessage.contentType = nil</div></div><!-- fragment --><p>One minor oddity with this approach is that nil will be auto-converted to the default value of the enum in any context, not just field assignment. In other words, this is valid:</p>
<div class="fragment"><div class="line">func foo(contentType: ContentType) { ... }</div><div class="line">foo(nil) // Inside foo, contentType == .text</div></div><!-- fragment --><p>That being said, the advantage of being able to simultaneously support nil-resettability and switch-without-unwrapping outweighs this side effect, especially if appropriately documented. It is our hope that a new form of resettable properties will be added to Swift that eliminates this inconsistency. Some community members have already drafted or sent proposals for review that would benefit our designs:</p>
<ul>
<li>https://github.com/apple/swift-evolution/blob/master/proposals/0030-property-behavior-decls.md "SE-0030: Property Behaviors"</li>
<li>https://github.com/patters/swift-evolution/blob/master/proposals/0000-resettable-properties.md "Drafted: Resettable Properties"</li>
</ul>
<h3>Enum aliases</h3>
<p><a class="el" href="protocol_the-p.html">The</a> <code>allow_alias</code> option in protobuf slightly complicates the use of Swift enums to represent that type, because raw values of cases in an enum must be unique. Swift lets us define static variables in an enum that alias actual cases. For example, the following protobuf enum:</p>
<div class="fragment"><div class="line">enum Foo {</div><div class="line">  option allow_alias = true;</div><div class="line">  BAR = 0;</div><div class="line">  BAZ = 0;</div><div class="line">}</div></div><!-- fragment --><p>will be represented in Swift as:</p>
<div class="fragment"><div class="line">public enum Foo: Int32, NilLiteralConvertible {</div><div class="line">  case bar = 0</div><div class="line">  static public let baz = bar</div><div class="line"></div><div class="line">  // ... etc.</div><div class="line">}</div><div class="line"></div><div class="line">// Can still use .baz shorthand to reference the alias in contexts</div><div class="line">// where the type is inferred</div></div><!-- fragment --><p>That is, we use the first name as the actual case and use static variables for the other aliases. One drawback to this approach is that the static aliases cannot be used as cases in a switch statement (the compiler emits the error <em>“Enum case ‘baz’ not found in type ‘Foo’”</em>). However, in our own code bases, there are only a few places where enum aliases are not mere renamings of an older value, but they also don’t appear to be the type of value that one would expect to switch on (for example, a group of named constants representing metrics rather than a set of options), so this restriction is not significant.</p>
<p>This strategy also implies that changing the name of an enum and adding the old name as an alias below the new name will be a breaking change in the generated Swift code.</p>
<h2>Oneof types</h2>
<p><a class="el" href="protocol_the-p.html">The</a> <code>oneof</code> feature represents a “variant/union” data type that maps nicely to Swift enums with associated values (algebraic types). These fields can also be accessed independently though, and, specifically in the case of proto2, it’s reasonable to expect access to default values when accessing a field that is not explicitly set.</p>
<p>Taking all this into account, we can represent a <code>oneof</code> in Swift with two sets of constructs:</p>
<ul>
<li>Properties in the message that correspond to the <code>oneof</code> fields.</li>
<li><a class="el" href="struct_a.html">A</a> nested enum named after the <code>oneof</code> and which provides the corresponding field values as case arguments.</li>
</ul>
<p>This approach fulfills the needs of proto consumers by providing a Swift-idiomatic way of simultaneously checking which field is set and accessing its value, providing individual properties to access the default values (important for proto2), and safely allows a field to be moved into a <code>oneof</code> without breaking clients.</p>
<p>Consider the following proto:</p>
<div class="fragment"><div class="line">message MyMessage {</div><div class="line">  oneof record {</div><div class="line">    string name = 1 [default = &quot;unnamed&quot;];</div><div class="line">    int32 id_number = 2 [default = 0];</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>In Swift, we would generate an enum, a property for that enum, and properties for the fields themselves:</p>
<div class="fragment"><div class="line">public struct MyMessage: ProtoMessage {</div><div class="line">  public enum Record: NilLiteralConvertible {</div><div class="line">    case name(String)</div><div class="line">    case idNumber(Int32)</div><div class="line">    case NOT_SET</div><div class="line"></div><div class="line">    public init(nilLiteral: ()) { self = .NOT_SET }</div><div class="line">  }</div><div class="line"></div><div class="line">  // This is the &quot;Swifty&quot; way of accessing the value</div><div class="line">  public var record: Record { ... }</div><div class="line"></div><div class="line">  // Direct access to the underlying fields</div><div class="line">  public var name: String! { ... }</div><div class="line">  public var idNumber: Int32! { ... }</div><div class="line">}</div></div><!-- fragment --><p>This makes both usage patterns possible:</p>
<div class="fragment"><div class="line">// Usage 1: Case-based dispatch</div><div class="line">switch message.record {</div><div class="line">  case .name(let name):</div><div class="line">    // Do something with name if it was explicitly set</div><div class="line">  case .idNumber(let id):</div><div class="line">    // Do something with id_number if it was explicitly set</div><div class="line">  case .NOT_SET:</div><div class="line">    // Do something if it’s not set</div><div class="line">}</div><div class="line"></div><div class="line">// Usage 2: Direct access for default value fallback</div><div class="line">// Sets the label text to the name if it was explicitly set, or to</div><div class="line">// &quot;unnamed&quot; (the default value for the field) if id_number was set</div><div class="line">// instead</div><div class="line">let myLabel = UILabel()</div><div class="line">myLabel.text = message.name</div></div><!-- fragment --><p>As with proto enums, the generated <code>oneof</code> enum conforms to <code>NilLiteralConvertible</code> to avoid switch statement issues. Setting the property to nil will clear it (i.e., reset it to <code>NOT_SET</code>).</p>
<h2>Unknown Fields (proto2 only)</h2>
<p>To be written.</p>
<h2>Extensions (proto2 only)</h2>
<p>To be written.</p>
<h2>Reflection and Descriptors</h2>
<p>We will not include reflection or descriptors in the first version of the Swift library. <a class="el" href="protocol_the-p.html">The</a> use cases for reflection on mobile are not as strong and the static data to represent the descriptors would add bloat when we wish to keep the code size small.</p>
<p>In the future, we will investigate whether they can be included as extensions which might be able to be excluded from a build and/or automatically dead stripped by the compiler if they are not used.</p>
<h2>Appendix <a class="el" href="struct_a.html">A</a>: Rejected strategies to handle packages</h2>
<h3>Each package is its own Swift module</h3>
<p>Each proto package could be declared as its own Swift module, replacing dots with underscores (e.g., package <code>foo.bar</code> becomes module <code>Foo_Bar</code>). Then, users would simply import modules containing whatever proto modules they want to use and refer to the generated types by their short names.</p>
<p><b>This solution is simply not possible, however.</b> Swift modules cannot circularly reference each other, but there is no restriction against proto packages doing so. Circular imports are forbidden (e.g., <code>foo.proto</code> importing <code>bar.proto</code> importing <code>foo.proto</code>), but nothing prevents package <code>foo</code> from using a type in package <code>bar</code> which uses a different type in package <code>foo</code>, as long as there is no import cycle. If these packages were generated as Swift modules, then <code>Foo</code> would contain an <code>import Bar</code> statement and <code>Bar</code> would contain an <code>import Foo</code> statement, and there is no way to compile this.</p>
<h3>Ad hoc namespacing with structs</h3>
<p>We can “fake” namespaces in Swift by declaring empty structs with private initializers. Since modules are constructed based on compiler arguments, not by syntactic constructs, and because there is no pure Swift way to define submodules (even though Clang module maps support this), there is no source-drive way to group generated code into namespaces aside from this approach.</p>
<p>Types can be added to those intermediate package structs using Swift extensions. For example, a message <code>Baz</code> in package <code>foo.bar</code> could be represented in Swift as follows:</p>
<div class="fragment"><div class="line">public struct Foo {</div><div class="line">  private init() {}</div><div class="line">}</div><div class="line"></div><div class="line">public extension Foo {</div><div class="line">  public struct Bar {</div><div class="line">    private init() {}</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">public extension Foo.Bar {</div><div class="line">  public struct Baz {</div><div class="line">    // Message fields and other methods</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">let baz = Foo.Bar.Baz()</div></div><!-- fragment --><p>Each of these constructs would actually be defined in a separate file; Swift lets us keep them separate and add multiple structs to a single “namespace” through extensions.</p>
<p>Unfortunately, these intermediate structs generate symbols of their own (metatype information in the data segment). This becomes problematic if multiple build targets contain Swift sources generated from different messages in the same package. At link time, these symbols would collide, resulting in multiple definition errors.</p>
<p>This approach also has the disadvantage that there is no automatic “short” way to refer to the generated messages at the deepest nesting levels; since this use of structs is a hack around the lack of namespaces, there is no equivalent to import (Java) or using (C++) to simplify this. Users would have to declare type aliases to make this cleaner, or we would have to generate them for users. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
