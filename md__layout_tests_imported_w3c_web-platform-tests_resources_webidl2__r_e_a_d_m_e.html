<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>webkit: WebIDL 2</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">webkit
   &#160;<span id="projectnumber">2cdf99a9e3038c7e01b3c37e8ad903ecbe5eecf1</span>
   </div>
   <div id="projectbrief">https://github.com/WebKit/webkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">WebIDL 2 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="http://badge.fury.io/js/webidl2"></a></p>
<h1>Purpose </h1>
<p>This is a parser for the <a href="http://dev.w3.org/2006/webapi/WebIDL/">WebIDL</a> language. If you don't know what that is, then you probably don't need it. It is meant to be used both in <a class="el" href="interface_node.html">Node</a> and in the browser (the parser likely works in other JS environments, but not the test suite).</p>
<h2>What of v1? </h2>
<p>There was a previous incarnation of this project. <a class="el" href="class_i.html">I</a> had written it in the most quick and dirty manner that was handy because <a class="el" href="class_i.html">I</a> required it as a dependency in an experiment. As these things tend to happen, some people started using that, which then had to be maintained. But since it was not built on solid foundations, it was painful to keep up to date with the specification, which is a bit of a moving target.</p>
<p>So <a class="el" href="class_i.html">I</a> started from scratch. Compared to the previous version (which used a parser generator) this one is about 6x less code (which translates to 4x smaller minified or 2x smaller minizipped) and 4x faster. <a class="el" href="protocol_the-p.html">The</a> test suite is reasonably complete (95% coverage), much more than previously. This version is up to date with WebIDL, rather than a couple years' behind. It also has <em>far</em> better error reporting.</p>
<p><a class="el" href="protocol_the-p.html">The</a> AST you get from parsing is very similar to the one you got in v1, but some adjustments have been made in order to be more systematic, and to map better to what's actually in the spec now. If you used v1, you will need to tweak your code but the result ought to be simpler and you ought to be able to be a fair bit less defensive against irregularities in the way information is represented.</p>
<h1>Installation </h1>
<p>Just the usual. For <a class="el" href="interface_node.html">Node</a>: </p><pre class="fragment">npm install webidl2
</pre><p>In the browser: </p><pre class="fragment">&lt;script src='webidl2.js'&gt;&lt;/script&gt;
</pre><h1>Documentation </h1>
<p><a class="el" href="protocol_the-p.html">The</a> <a class="el" href="namespace_a_p_i.html">API</a> to WebIDL2 is trivial: you parse a string of WebIDL and it returns a syntax tree.</p>
<h2>Parsing </h2>
<p>In <a class="el" href="interface_node.html">Node</a>, that happens with: </p><pre class="fragment">var WebIDL2 = require("webidl2");
var tree = WebIDL2.parse("string of WebIDL");
</pre><p>In the browser: </p><pre class="fragment">&lt;script src='webidl2.js'&gt;&lt;/script&gt;
&lt;script&gt;
  var tree = WebIDL2.parse("string of WebIDL");
&lt;/script&gt;
</pre><h2>Advanced Parsing </h2>
<p><code><a class="el" href="namespace_j_s_c.html#aec05d93957c054d994c00841148772f3">parse()</a></code> can optionally accept a second parameter, an options object, which can be used to modify parsing behavior.</p>
<p><a class="el" href="protocol_the-p.html">The</a> following options are recognized: </p><div class="fragment"><div class="line">{</div><div class="line">    allowNestedTypedefs: false # </div><div class="line">}</div></div><!-- fragment --><p> And their meanings are as follows:</p>
<ul>
<li><code>allowNestedTypedefs</code>: Boolean indicating whether the parser should accept <code>typedef</code>s as valid members of <code>interface</code>s. This is non-standard syntax and therefore the default is <code>false</code>.</li>
</ul>
<h2>Errors </h2>
<p>When there is a syntax error in the WebIDL, it throws an exception object with the following properties:</p>
<ul>
<li><code>message</code>: the error message</li>
<li><code>line</code>: the line at which the error occurred.</li>
<li><code>input</code>: a short peek at the text at the point where the error happened</li>
<li><code>tokens</code>: the five tokens at the point of error, as understood by the tokeniser (this is the same content as <code>input</code>, but seen from the tokeniser's point of view)</li>
</ul>
<p><a class="el" href="protocol_the-p.html">The</a> exception also has a <code><a class="el" href="namespace_w_t_f.html#a44b62dc5e85a12a1ccb891d2057a2db2">toString()</a></code> method that hopefully should produce a decent error message.</p>
<h2>AST (Abstract Syntax Tree) </h2>
<p><a class="el" href="protocol_the-p.html">The</a> <code><a class="el" href="namespace_j_s_c.html#aec05d93957c054d994c00841148772f3">parse()</a></code> method returns a tree object representing the parse tree of the IDL. <a class="el" href="interface_comment.html">Comment</a> and white space are not represented in the AST.</p>
<p><a class="el" href="protocol_the-p.html">The</a> root of this object is always an array of definitions (where definitions are any of interfaces, exceptions, callbacks, etc. â€” anything that can occur at the root of the IDL).</p>
<h3>IDL Type</h3>
<p>This structure is used in many other places (operation return types, argument types, etc.). It captures a WebIDL type with a number of options. Types look like this and are typically attached to a field called <code>idlType</code>: </p><pre class="fragment">{
    "sequence": false,
    "generic": null,
    "nullable": false,
    "array": false,
    "union": false,
    "idlType": "void"
}
</pre><p>Where the fields are as follows:</p>
<ul>
<li><code>sequence</code>: Boolean indicating whether this is a sequence or not. <a class="el" href="namespace_deprecated.html">Deprecated</a>. Use <code>generic</code> instead.</li>
<li><code>generic</code>: String indicating the generic type (e.g. "Promise", "sequence"). <code>null</code> otherwise.</li>
<li><code>nullable</code>: Boolean indicating whether this is nullable or not.</li>
<li><code>array</code>: Either <code>false</code> to indicate that it is not an array, or a number for the level of array nesting.</li>
<li><code>union</code>: Boolean indicating whether this is a union type or not.</li>
<li><code>idlType</code>: Can be different things depending on context. In most cases, this will just be a string with the type name. But the reason this field isn't called "typeName" is because it can take more complex values. If the type is a union, then this contains an array of the types it unites. If it is a generic type, it contains the IDL type description for the type in the sequence, the eventual value of the promise, etc.</li>
</ul>
<h4>Interactions between <code>nullable</code> and <code>array</code></h4>
<p><a class="el" href="struct_a.html">A</a> more complex data model for our AST would likely represent <code>Foo[][][]</code> as a series of nested types four levels deep with three anonymous array types eventually containing a <code>Foo</code> type. But experience shows that such structures are cumbersome to use, and so we have a simpler model in which the depth of the array is specified with the <code>array</code> field.</p>
<p>This is all fine and well, and in the vast majority of cases is actually simpler. But it does run afoul of cases in which it is necessary to distinguish between <code>Foo[][][]?</code>, <code>Foo?[][][]</code>, <code>Foo[][]?[]</code>, or even <code>Foo?[]?[]?[]?</code>.</p>
<p>For this, when a type is an array type an additional <code>nullableArray</code> field is made available that captures which of the arrays contain nullable elements. It contains booleans that are true if the given array depth contains nullable elements, and false otherwise (mapping that to the syntax, and item is true if there is a <code>?</code> preceding the <code>[]</code>). These examples ought to clarify the model: </p><pre class="fragment">Foo[][][]?
    -&gt; nullable: true
    -&gt; nullableArray: [false, false, false]
Foo?[][][]
    -&gt; nullable: false
    -&gt; nullableArray: [true, false, false]
Foo[][]?[]
    -&gt; nullable: false
    -&gt; nullableArray: [false, false, true]
Foo?[]?[]?[]?
    -&gt; nullable: true
    -&gt; nullableArray: [true, true, true]
</pre><p>Of particular importance, please note that the overall type is only <code>nullable</code> if there is a <code>?</code> at the end.</p>
<h3>Interface</h3>
<p>Interfaces look like this: </p><pre class="fragment">{
    "type": "interface",
    "name": "Animal",
    "partial": false,
    "members": [...],
    "inheritance": null,
    "extAttrs": [...]
},
{
    "type": "interface",
    "name": "Human",
    "partial": false,
    "members": [...],
    "inheritance": "Animal",
    "extAttrs": [...]
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "interface".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> name of the interface</li>
<li><code>partial</code>: <a class="el" href="struct_a.html">A</a> boolean indicating whether it's a partial interface.</li>
<li><code>members</code>: An array of interface members (attributes, operations, etc.). Empty if there are none.</li>
<li><code>inheritance</code>: <a class="el" href="struct_a.html">A</a> string giving the name of an interface this one inherits from, <code>null</code> otherwise. <b>NOTE</b>: In v1 this was an array, but multiple inheritance is no longer supported so this didn't make sense.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Callback Interfaces</h3>
<p>These are captured by the same structure as <a href="#interface">Interfaces</a> except that their <code>type</code> field is "callback interface".</p>
<h3>Callback</h3>
<p><a class="el" href="struct_a.html">A</a> callback looks like this:</p>
<p>{ "type": "callback", "name": "AsyncOperationCallback", "idlType": { "sequence": false, "generic": null, "nullable": false, "array": false, "union": false, "idlType": "void" }, "arguments": [...], "extAttrs": [] }</p>
<p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "callback".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> name of the callback.</li>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> describing what the callback returns.</li>
<li><code>arguments</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#arguments">arguments</a>, as in function paramters.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Dictionary</h3>
<p><a class="el" href="struct_a.html">A</a> dictionary looks like this: </p><pre class="fragment">{
    "type": "dictionary",
    "name": "PaintOptions",
    "partial": false,
    "members": [
        {
            "type": "field",
            "name": "fillPattern",
            "required": false,
            "idlType": {
                "sequence": false,
                "generic": null,
                "nullable": true,
                "array": false,
                "union": false,
                "idlType": "DOMString"
            },
            "extAttrs": [],
            "default": {
                "type": "string",
                "value": "black"
            }
        }
    ],
    "inheritance": null,
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "dictionary".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> dictionary name.</li>
<li><code>partial</code>: Boolean indicating whether it's a partial dictionary.</li>
<li><code>members</code>: An array of members (see below).</li>
<li><code>inheritance</code>: <a class="el" href="struct_a.html">A</a> string indicating which dictionary is being inherited from, <code>null</code> otherwise.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<p>All the members are fields as follows:</p>
<ul>
<li><code>type</code>: Always "field".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> name of the field.</li>
<li><code>required</code>: Boolean indicating whether this is a <a href="https://heycam.github.io/webidl/#required-dictionary-member">required</a> field.</li>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> describing what field's type.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
<li><code>default</code>: <a class="el" href="struct_a.html">A</a> <a href="#default-and-const-values">default value</a>, absent if there is none.</li>
</ul>
<h3>Exception</h3>
<p>An exception looks like this: </p><pre class="fragment">{
    "type": "exception",
    "name": "HierarchyRequestError",
    "members": [
        {
            "type": "field",
            "name": "code",
            "idlType": {
                "sequence": false,
                "generic": null,
                "nullable": false,
                "array": false,
                "union": false,
                "idlType": "unsigned short"
            },
            "extAttrs": []
        }
    ],
    "inheritance": "DOMException",
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "exception".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> exception name.</li>
<li><code>members</code>: An array of members (constants or fields, where fields are described below).</li>
<li><code>inheritance</code>: <a class="el" href="struct_a.html">A</a> string indicating which exception is being inherited from, <code>null</code> otherwise.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<p>Members that aren't <a href="#constants">constants</a> have the following fields:</p>
<ul>
<li><code>type</code>: Always "field".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> field's name.</li>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> describing what field's type.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Enum</h3>
<p>An enum looks like this: </p><pre class="fragment">{
    "type": "enum",
    "name": "MealType",
    "values": [
        "rice",
        "noodles",
        "other"
    ],
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "enum".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> enum's name.</li>
<li><code>value</code>: An array of values (strings).</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Typedef</h3>
<p><a class="el" href="struct_a.html">A</a> typedef looks like this: </p><pre class="fragment">{
    "type": "typedef",
    "typeExtAttrs": [],
    "idlType": {
        "sequence": true,
        "generic": "sequence",
        "nullable": false,
        "array": false,
        "union": false,
        "idlType": {
            "sequence": false,
            "generic": null,
            "nullable": false,
            "array": false,
            "union": false,
            "idlType": "Point"
        }
    },
    "name": "PointSequence",
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "typedef".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> typedef's name.</li>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> describing what typedef's type.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
<li><code>typeExtAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a> that apply to the type rather than to the typedef as a whole.</li>
</ul>
<h3>Implements</h3>
<p>An implements definition looks like this: </p><pre class="fragment">{
    "type": "implements",
    "target": "Node",
    "implements": "EventTarget",
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "implements".</li>
<li><code>target</code>: <a class="el" href="protocol_the-p.html">The</a> interface that implements another.</li>
<li><code>implements</code>: <a class="el" href="protocol_the-p.html">The</a> interface that is being implemented by the target.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Operation Member</h3>
<p>An operation looks like this: </p><pre class="fragment">{
    "type": "operation",
    "getter": false,
    "setter": false,
    "creator": false,
    "deleter": false,
    "legacycaller": false,
    "static": false,
    "stringifier": false,
    "idlType": {
        "sequence": false,
        "generic": null,
        "nullable": false,
        "array": false,
        "union": false,
        "idlType": "void"
    },
    "name": "intersection",
    "arguments": [
        {
            "optional": false,
            "variadic": true,
            "extAttrs": [],
            "idlType": {
                "sequence": false,
                "generic": null,
                "nullable": false,
                "array": false,
                "union": false,
                "idlType": "long"
            },
            "name": "ints"
        }
    ],
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "operation".</li>
<li><code>getter</code>: True if a getter operation.</li>
<li><code>setter</code>: True if a setter operation.</li>
<li><code>creator</code>: True if a creator operation.</li>
<li><code>deleter</code>: True if a deleter operation.</li>
<li><code>legacycaller</code>: True if a legacycaller operation.</li>
<li><code>static</code>: True if a static operation.</li>
<li><code>stringifier</code>: True if a stringifier operation.</li>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> of what the operation returns. If a stringifier, may be absent.</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> name of the operation. If a stringifier, may be <code>null</code>.</li>
<li><code>arguments</code>: An array of <a href="#arguments">arguments</a> for the operation.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Attribute Member</h3>
<p>An attribute member looks like this: </p><pre class="fragment">{
    "type": "attribute",
    "static": false,
    "stringifier": false,
    "inherit": false,
    "readonly": false,
    "idlType": {
        "sequence": false,
        "generic": null,
        "nullable": false,
        "array": false,
        "union": false,
        "idlType": "RegExp"
    },
    "name": "regexp",
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "attribute".</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> attribute's name.</li>
<li><code>static</code>: True if it's a static attribute.</li>
<li><code>stringifier</code>: True if it's a stringifier attribute.</li>
<li><code>inherit</code>: True if it's an inherit attribute.</li>
<li><code>readonly</code>: True if it's a read-only attribute.</li>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> for the attribute.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Constant Member</h3>
<p><a class="el" href="struct_a.html">A</a> constant member looks like this: </p><pre class="fragment">{
    "type": "const",
    "nullable": false,
    "idlType": "boolean",
    "name": "DEBUG",
    "value": {
        "type": "boolean",
        "value": false
    },
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always "const".</li>
<li><code>nullable</code>: Whether its type is nullable.</li>
<li><code>idlType</code>: <a class="el" href="protocol_the-p.html">The</a> type of the constant (a simple type, the type name).</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> name of the constant.</li>
<li><code>value</code>: <a class="el" href="protocol_the-p.html">The</a> constant value as described by <a href="#default-and-const-values">Const Values</a></li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Serializer Member</h3>
<p>Serializers come in many shapes, which are best understood by looking at the examples below that map the IDL to the produced AST. </p><pre class="fragment">// serializer;
{
    "type": "serializer",
    "extAttrs": []
}

// serializer DOMString serialize();
{
    "type": "serializer",
    "idlType": {
        "sequence": false,
        "generic": null,
        "nullable": false,
        "array": false,
        "union": false,
        "idlType": "DOMString"
    },
    "operation": {
        "name": "serialize",
        "arguments": []
    },
    "extAttrs": []
}

// serializer = { from, to, amount, description };
{
    "type": "serializer",
    "patternMap": true,
    "names": [
        "from",
        "to",
        "amount",
        "description"
    ],
    "extAttrs": []
}

// serializer = number;
{
    "type": "serializer",
    "name": "number",
    "extAttrs": []
}

// serializer = [ name, number ];
{
    "type": "serializer",
    "patternList": true,
    "names": [
        "name",
        "number"
    ],
    "extAttrs": []
}
</pre><p><a class="el" href="protocol_the-p.html">The</a> common fields are as follows:</p>
<ul>
<li><code>type</code>: Always "serializer".</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<p>For a simple serializer, that's all there is. If the serializer is an operation, it will have:</p>
<ul>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> describing what the serializer returns.</li>
<li><code>operation</code>: An object with the following fields:<ul>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> name of the operation.</li>
<li><code>arguments</code>: An array of <a href="#arguments">arguments</a> for the operation.</li>
</ul>
</li>
</ul>
<p>If the serializer is a pattern map:</p>
<ul>
<li><code>patternMap</code>: Always true.</li>
<li><code>names</code>: An array of names in the pattern map.</li>
</ul>
<p>If the serializer is a pattern list:</p>
<ul>
<li><code>patternList</code>: Always true.</li>
<li><code>names</code>: An array of names in the pattern list.</li>
</ul>
<p>Finally, if the serializer is a named serializer:</p>
<ul>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> serializer's name.</li>
</ul>
<h3>Iterator Member</h3>
<p>Iterator members look like this </p><pre class="fragment">{
    "type": "iterator",
    "getter": false,
    "setter": false,
    "creator": false,
    "deleter": false,
    "legacycaller": false,
    "static": false,
    "stringifier": false,
    "idlType": {
        "sequence": false,
        "generic": null,
        "nullable": false,
        "array": false,
        "union": false,
        "idlType": "Session2"
    },
    "iteratorObject": "SessionIterator",
    "extAttrs": []
}
</pre><ul>
<li><code>type</code>: Always "iterator".</li>
<li><code>iteratorObject</code>: <a class="el" href="protocol_the-p.html">The</a> string on the right-hand side; absent if there isn't one.</li>
<li>the rest: same as on <a href="#operation-member">operations</a>.</li>
</ul>
<h3>Arguments</h3>
<p><a class="el" href="protocol_the-p.html">The</a> arguments (e.g. for an operation) look like this: </p><pre class="fragment">"arguments": [
    {
        "optional": false,
        "variadic": true,
        "extAttrs": [],
        "idlType": {
            "sequence": false,
            "generic": null,
            "nullable": false,
            "array": false,
            "union": false,
            "idlType": "long"
        },
        "name": "ints"
    }
]
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>optional</code>: True if the argument is optional.</li>
<li><code>variadic</code>: True if the argument is variadic.</li>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> describing the type of the argument.</li>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> argument's name.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h3>Extended Attributes</h3>
<p>Extended attributes are arrays of items that look like this: </p><pre class="fragment">"extAttrs": [
    {
        "name": "TreatNullAs",
        "arguments": null,
        "rhs": {
            "type": "identifier",
            "value": "EmptyString"
        }
    }
]
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>name</code>: <a class="el" href="protocol_the-p.html">The</a> extended attribute's name.</li>
<li><code>arguments</code>: If the extended attribute takes arguments (e.g. <code>[Foo()]</code>) or if its right-hand side does (e.g. <code>[NamedConstructor=Name(DOMString blah)]</code>) they are listed here. Note that an empty arguments list will produce an empty array, whereas the lack thereof will yield a <code>null</code>. If there is an <code>rhs</code> field then they are the right-hand side's arguments, otherwise they apply to the extended attribute directly.</li>
<li><code>rhs</code>: If there is a right-hand side, this will capture its <code>type</code> (which can be "identifier" or "identifier-list") and its <code>value</code>.</li>
<li><code>typePair</code>: If the extended attribute is a <code>MapClass</code> this will capture the map's key type and value type respectively.</li>
</ul>
<h3>Default and Const Values</h3>
<p>Dictionary fields and operation arguments can take default values, and constants take values, all of which have the following fields:</p>
<ul>
<li><code>type</code>: One of string, number, boolean, null, Infinity, NaN, or sequence.</li>
</ul>
<p>For string, number, boolean, and sequence:</p>
<ul>
<li><code>value</code>: <a class="el" href="protocol_the-p.html">The</a> value of the given type. For sequence, the only possible value is <code>[]</code>.</li>
</ul>
<p>For Infinity:</p>
<ul>
<li><code>negative</code>: Boolean indicating whether this is negative Infinity or not.</li>
</ul>
<h3><code>iterable&lt;&gt;</code>, <code>legacyiterable&lt;&gt;</code>, <code>maplike&lt;&gt;</code>, <code>setlike&lt;&gt;</code> declarations</h3>
<p>These appear as members of interfaces that look like this: </p><pre class="fragment">    {
        "type": "maplike", // or "legacyiterable" / "iterable" / "setlike"
        "idlType": /* One or two types */,
        "readonly": false, // only for maplike and setlike
        "extAttrs": []
    }
</pre><p><a class="el" href="protocol_the-p.html">The</a> fields are as follows:</p>
<ul>
<li><code>type</code>: Always one of "iterable", "legacyiterable", "maplike" or "setlike".</li>
<li><code>idlType</code>: An <a href="#idl-type">IDL Type</a> (or an array of two types) representing the declared type arguments.</li>
<li><code>readonly</code>: Whether the maplike or setlike is declared as read only.</li>
<li><code>extAttrs</code>: <a class="el" href="struct_a.html">A</a> list of <a href="#extended-attributes">extended attributes</a>.</li>
</ul>
<h1>Testing </h1>
<p>In order to run the tests you need to ensure that the widlproc submodule inside <code>test</code> is initialised and up to date: </p><pre class="fragment">git submodule init
git submodule update
</pre><h2>Running </h2>
<p><a class="el" href="protocol_the-p.html">The</a> test runs with mocha and expect.js. Normally, running mocha in the root directory should be enough once you're set up.</p>
<h2>Coverage </h2>
<p>Current test coverage, as documented in <code>coverage.html</code>, is 95%. You can run your own coverage analysis with: </p><pre class="fragment">jscoverage lib lib-cov
</pre><p>That will create the lib-cov directory with instrumented code; the test suite knows to use that if needed. You can then run the tests with: </p><pre class="fragment">JSCOV=1 mocha --reporter html-cov &gt; coverage.html
</pre><p>Note that <a class="el" href="class_i.html">I</a>'ve been getting weirdly overescaped results from the html-cov reporter, so you might wish to try this instead: </p><pre class="fragment">JSCOV=1 mocha  --reporter html-cov | sed "s/&amp;lt;/&lt;/g" | sed "s/&amp;gt;/&gt;/g" | sed "s/&amp;quot;/\"/g" &gt; coverage.html
</pre><h2>Browser tests </h2>
<p>In order to test in the browser, get inside <code>test/web</code> and run <code>make-web-tests.js</code>. This will generate a <code>browser-tests.html</code> file that you can open in a browser. As of this writing tests pass in the latest Firefox, Chrome, Opera, and Safari. Testing on IE and older versions will happen progressively.</p>
<h1>TODO </h1>
<ul>
<li>add some tests to address coverage limitations</li>
<li>add a push <a class="el" href="namespace_a_p_i.html">API</a> for processors that need to process things like comments </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
